[
  {
    "urn": {
      "tags": {
        "op": "transcribe",
        "model_type": "candle",
        "in": "media:wav;audio;binary;",
        "out": "media:transcription-output;textable;keyed"
      }
    },
    "command": "transcribe",
    "title": "Transcribe Audio (Candle)",
    "cap_description": "Transcribe audio files to text using Whisper models with Candle ML framework",
    "metadata": {},
    "media_specs": {
      "media:transcription-output;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/transcription-output",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "required": [
            "model_name",
            "audio_path",
            "language",
            "text"
          ],
          "properties": {
            "model_name": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the Whisper model used"
            },
            "audio_path": {
              "type": "string",
              "description": "Path to the transcribed audio file"
            },
            "language": {
              "type": "string",
              "description": "Language of the transcription"
            },
            "text": {
              "type": "string",
              "description": "Full transcribed text"
            },
            "segments": {
              "type": "array",
              "description": "Timestamped segments (if timestamps enabled)",
              "items": {
                "type": "object",
                "additionalProperties": false,
                "required": [
                  "segment_index",
                  "start_time",
                  "end_time",
                  "text"
                ],
                "properties": {
                  "segment_index": {
                    "type": "integer",
                    "minimum": 0,
                    "description": "Index of this segment"
                  },
                  "start_time": {
                    "type": "number",
                    "minimum": 0,
                    "description": "Start time in seconds"
                  },
                  "end_time": {
                    "type": "number",
                    "minimum": 0,
                    "description": "End time in seconds"
                  },
                  "text": {
                    "type": "string",
                    "description": "Text content of this segment"
                  }
                }
              }
            },
            "duration_seconds": {
              "type": "number",
              "minimum": 0,
              "description": "Total audio duration in seconds"
            },
            "transcription_time_ms": {
              "type": "integer",
              "minimum": 0,
              "description": "Transcription time in milliseconds"
            }
          }
        }
      }
    },
    "args": [
      {
        "media_urn": "media:audio-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "cli_flag": "--audio"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the audio file (WAV format)",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:language-code;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--language"
          }
        ],
        "arg_description": "Language code for transcription",
        "validation": {
          "pattern": "^[a-z]{2}$"
        },
        "default_value": "en"
      },
      {
        "media_urn": "media:timestamps-flag;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--timestamps"
          }
        ],
        "arg_description": "Include timestamps in output",
        "default_value": false
      },
      {
        "media_urn": "media:hf-model-name;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--model"
          }
        ],
        "arg_description": "Whisper model name from HuggingFace",
        "validation": {
          "min_length": 1,
          "max_length": 256
        },
        "default_value": "openai/whisper-base"
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Output JSON file path",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      }
    ],
    "output": {
      "media_urn": "media:transcription-output;textable;keyed",
      "output_description": "Transcribed text with optional timestamps and metadata"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "choose_bit",
        "language": "en",
        "type": "constrained",
        "in": "media:content-text;textable;scalar",
        "out": "media:boolean;textable;scalar"
      }
    },
    "command": "bit_choice",
    "title": "Make a Choice",
    "cap_description": "Make a single binary (yes/no, true/false) decision based on content and a question",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:content-text;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:content-text;textable;scalar"
          },
          {
            "cli_flag": "--content"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Content to analyze for the binary decision",
        "validation": {
          "min_length": 1,
          "max_length": 65536
        }
      },
      {
        "media_urn": "media:question-text;textable;scalar",
        "required": true,
        "sources": [
          {
            "cli_flag": "--question"
          },
          {
            "position": 1
          }
        ],
        "arg_description": "The binary question to answer about the content",
        "validation": {
          "min_length": 5,
          "max_length": 4096
        }
      },
      {
        "media_urn": "media:language-code;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--language"
          }
        ],
        "arg_description": "Language code for processing",
        "validation": {
          "allowed_values": [
            "en",
            "es",
            "fr",
            "de",
            "it",
            "pt",
            "ru",
            "zh",
            "ja",
            "ko"
          ]
        },
        "default_value": "en"
      },
      {
        "media_urn": "media:max-content-length;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--max-content-length"
          }
        ],
        "arg_description": "Maximum content length to consider (for context window management)",
        "validation": {
          "min": 256,
          "max": 131072
        },
        "default_value": 2048
      },
      {
        "media_urn": "media:confidence-threshold;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--confidence-threshold"
          }
        ],
        "arg_description": "Minimum confidence threshold for decisions",
        "validation": {
          "min": 0,
          "max": 1
        },
        "default_value": 0.7
      },
      {
        "media_urn": "media:model-spec;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--model-spec"
          }
        ],
        "arg_description": "Model spec to use for decision making",
        "validation": {
          "pattern": ".*:.*",
          "min_length": 4,
          "max_length": 512
        },
        "default_value": "hf:MaziyarPanahi/Mistral-7B-Instruct-v0.3-GGUF?include=*Q8_0*,*.json&exclude=*IQ1*,*IQ2*,*IQ3*,*Q2*,*Q3*"
      }
    ],
    "output": {
      "media_urn": "media:boolean;textable;scalar",
      "output_description": "Binary decision result (true/false)"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "choose_bits",
        "language": "en",
        "type": "constrained",
        "in": "media:content-text;textable;scalar",
        "out": "media:boolean-array;textable;sequence"
      }
    },
    "command": "bit_choices",
    "title": "Make Multiple Choices",
    "cap_description": "Make multiple binary (yes/no, true/false) decisions based on content and multiple questions",
    "metadata": {},
    "media_specs": {
      "media:string-array;textable;sequence": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/questions-array",
        "schema": {
          "type": "array",
          "minItems": 1,
          "maxItems": 50,
          "items": {
            "type": "string",
            "minLength": 5,
            "maxLength": 4096,
            "description": "A binary question to answer about the content"
          }
        }
      }
    },
    "args": [
      {
        "media_urn": "media:content-text;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:content-text;textable;scalar"
          },
          {
            "cli_flag": "--content"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Content to analyze for the binary decisions",
        "validation": {
          "min_length": 1,
          "max_length": 65536
        }
      },
      {
        "media_urn": "media:questions-array;textable;sequence",
        "required": true,
        "sources": [
          {
            "cli_flag": "--questions"
          },
          {
            "position": 1
          }
        ],
        "arg_description": "Array of binary questions to answer about the content"
      },
      {
        "media_urn": "media:language-code;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--language"
          }
        ],
        "arg_description": "Language code for processing",
        "validation": {
          "allowed_values": [
            "en",
            "es",
            "fr",
            "de",
            "it",
            "pt",
            "ru",
            "zh",
            "ja",
            "ko"
          ]
        },
        "default_value": "en"
      },
      {
        "media_urn": "media:max-content-length;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--max-content-length"
          }
        ],
        "arg_description": "Maximum content length to consider (for context window management)",
        "validation": {
          "min": 256,
          "max": 131072
        },
        "default_value": 2048
      },
      {
        "media_urn": "media:confidence-threshold;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--confidence-threshold"
          }
        ],
        "arg_description": "Minimum confidence threshold for decisions",
        "validation": {
          "min": 0,
          "max": 1
        },
        "default_value": 0.7
      },
      {
        "media_urn": "media:model-spec;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--model-spec"
          }
        ],
        "arg_description": "Model spec to use for decision making",
        "validation": {
          "pattern": ".*:.*",
          "min_length": 4,
          "max_length": 512
        },
        "default_value": "hf:MaziyarPanahi/Mistral-7B-Instruct-v0.3-GGUF?include=*Q8_0*,*.json&exclude=*IQ1*,*IQ2*,*IQ3*,*Q2*,*Q3*"
      }
    ],
    "output": {
      "media_urn": "media:boolean-array;textable;sequence",
      "output_description": "Array of boolean decision results corresponding to each question"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "disbind",
        "in": "media:log;textable",
        "out": "media:disbound-pages;textable;keyed;sequence"
      }
    },
    "command": "grind",
    "title": "Extract Log File Chips",
    "cap_description": "Grind with text content from log files",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:log;textable"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the log file to process",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:index-range;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--index-range"
          }
        ],
        "arg_description": "Index Range to extract (e.g., '1-5' or '10-')",
        "validation": {
          "pattern": "^\\d+(-\\d*)?$"
        }
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Write output to specified file instead of stdout",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      }
    ],
    "output": {
      "media_urn": "media:object;textable;keyed",
      "output_description": "Structured file chips with text content"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "disbind",
        "in": "media:md;textable",
        "out": "media:disbound-pages;textable;keyed;sequence"
      }
    },
    "command": "grind",
    "title": "Extract Markdown File Chips",
    "cap_description": "Grind with text content from markdown files",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:md;textable"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the markdown file to process",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:index-range;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--index-range"
          }
        ],
        "arg_description": "Index Range to extract (e.g., '1-5' or '10-')",
        "validation": {
          "pattern": "^\\d+(-\\d*)?$"
        }
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Write output to specified file instead of stdout",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      }
    ],
    "output": {
      "media_urn": "media:object;textable;keyed",
      "output_description": "Structured file chips with text content"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "disbind",
        "in": "media:pdf;binary",
        "out": "media:disbound-pages;textable;keyed;sequence"
      }
    },
    "command": "grind",
    "title": "Extract File Chips",
    "cap_description": "Extract structured page content from the document",
    "metadata": {},
    "media_specs": {
      "media:disbound-pages;textable;keyed;sequence": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/disbound-pages",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "required": [
            "source_file",
            "document_type",
            "total_pages",
            "pages",
            "extraction_info"
          ],
          "properties": {
            "source_file": {
              "type": "string",
              "minLength": 1,
              "description": "Source file path"
            },
            "document_type": {
              "type": "string",
              "description": "Document format/type (PDF, EPUB, etc.)"
            },
            "total_pages": {
              "type": "integer",
              "minimum": 0,
              "description": "Total number of pages in document"
            },
            "pages": {
              "type": "array",
              "description": "All pages in the document",
              "items": {
                "type": "object",
                "additionalProperties": false,
                "required": [
                  "order_index",
                  "text_content"
                ],
                "properties": {
                  "order_index": {
                    "type": "integer",
                    "minimum": 1,
                    "description": "Page number (1-indexed)"
                  },
                  "text_content": {
                    "type": "string",
                    "description": "Text content of this page as a single string"
                  },
                  "source_ref": {
                    "type": [
                      "string",
                      "null"
                    ],
                    "description": "Optional source reference (filename, section, etc.)"
                  },
                  "word_count": {
                    "type": [
                      "integer",
                      "null"
                    ],
                    "minimum": 0,
                    "description": "Word count for this page"
                  },
                  "character_count": {
                    "type": [
                      "integer",
                      "null"
                    ],
                    "minimum": 0,
                    "description": "Character count for this page"
                  }
                }
              }
            },
            "extraction_info": {
              "type": "object",
              "additionalProperties": false,
              "description": "Metadata about the extraction process",
              "required": [
                "extractor_name",
                "extractor_version",
                "warnings"
              ],
              "properties": {
                "extractor_name": {
                  "type": "string",
                  "description": "Tool that performed the extraction"
                },
                "extractor_version": {
                  "type": "string",
                  "description": "Version of the extraction tool"
                },
                "extracted_at": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "description": "Timestamp of extraction"
                },
                "warnings": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Any warnings or notes about the extraction"
                }
              }
            },
            "document_title": {
              "type": [
                "string",
                "null"
              ],
              "description": "Document title (from metadata if available)"
            }
          }
        }
      }
    },
    "args": [
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:pdf;binary"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the document file to process",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Write output to specified file instead of stdout",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      },
      {
        "media_urn": "media:index-range;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--index-range"
          }
        ],
        "arg_description": "Index Range to extract (e.g., '1-5' or '10-')",
        "validation": {
          "pattern": "^\\d+(-\\d*)?$"
        }
      }
    ],
    "output": {
      "media_urn": "media:disbound-pages;textable;keyed;sequence",
      "output_description": "Structured page content extracted from the document"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "disbind",
        "in": "media:rst;textable",
        "out": "media:disbound-pages;textable;keyed;sequence"
      }
    },
    "command": "grind",
    "title": "Extract RST File Chips",
    "cap_description": "Grind with text content from RST files",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:rst;textable"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the RST file to process",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:index-range;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--index-range"
          }
        ],
        "arg_description": "Index Range to extract (e.g., '1-5' or '10-')",
        "validation": {
          "pattern": "^\\d+(-\\d*)?$"
        }
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Write output to specified file instead of stdout",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      }
    ],
    "output": {
      "media_urn": "media:object;textable;keyed",
      "output_description": "Structured file chips with text content"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "disbind",
        "in": "media:txt;textable",
        "out": "media:disbound-pages;textable;keyed;sequence"
      }
    },
    "command": "grind",
    "title": "Extract Text File Chips",
    "cap_description": "Grind with text content from text files",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:txt;textable"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the text file to process",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:index-range;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--index-range"
          }
        ],
        "arg_description": "Index Range to extract (e.g., '1-5' or '10-')",
        "validation": {
          "pattern": "^\\d+(-\\d*)?$"
        }
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Write output to specified file instead of stdout",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      }
    ],
    "output": {
      "media_urn": "media:object;textable;keyed",
      "output_description": "Structured file chips with text content"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "embeddings_dimensions",
        "model_type": "candle",
        "in": "media:void",
        "out": "media:integer;textable;numeric;scalar"
      }
    },
    "command": "get_embedding_dimensions",
    "title": "Get Embeddings Dimensions (Candle)",
    "cap_description": "Query the dimensionality of embeddings for a given Candle model",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:hf-model-name;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--model"
          }
        ],
        "arg_description": "HuggingFace model name to query dimensions for",
        "validation": {
          "min_length": 1,
          "max_length": 256
        },
        "default_value": "sentence-transformers/all-MiniLM-L6-v2"
      }
    ],
    "output": {
      "media_urn": "media:integer;textable;numeric;scalar",
      "output_description": "Dimensionality of the embeddings (positive integer)",
      "validation": {
        "min": 1,
        "max": 100000
      }
    }
  },
  {
    "urn": {
      "tags": {
        "op": "embeddings_dimensions",
        "format": "gguf",
        "model_type": "gguf",
        "in": "media:void",
        "out": "media:integer;textable;numeric;scalar"
      }
    },
    "command": "get_embedding_dimensions",
    "title": "Get Embeddings Dimensions (GGUF)",
    "cap_description": "Query the dimensionality of embeddings for a given GGUF model",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:model-spec;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--model-spec"
          }
        ],
        "arg_description": "GGUF model specification to query dimensions for",
        "validation": {
          "min_length": 1,
          "max_length": 512
        },
        "default_value": "hf:nomic-ai/nomic-embed-text-v1.5-GGUF"
      }
    ],
    "output": {
      "media_urn": "media:integer;textable;numeric;scalar",
      "output_description": "Dimensionality of the embeddings (n_embd from model metadata)",
      "validation": {
        "min": 1,
        "max": 100000
      }
    }
  },
  {
    "urn": {
      "tags": {
        "op": "embeddings_dimensions",
        "model_type": "mlx",
        "in": "media:void",
        "out": "media:integer;textable;numeric;scalar"
      }
    },
    "command": "get_embedding_dimensions",
    "title": "Get Embeddings Dimensions (MLX)",
    "cap_description": "Query the dimensionality of embeddings for a given MLX model",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:mlx-model-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "cli_flag": "--model"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to MLX embedding model directory",
        "validation": {
          "min_length": 1
        }
      }
    ],
    "output": {
      "media_urn": "media:integer;textable;numeric;scalar",
      "output_description": "Dimensionality of the embeddings (positive integer)",
      "validation": {
        "min": 1,
        "max": 100000
      }
    }
  },
  {
    "urn": {
      "tags": {
        "op": "embeddings_dimensions",
        "in": "media:void",
        "out": "media:integer;textable;numeric;scalar"
      }
    },
    "command": "get_embedding_dimensions",
    "title": "Get Embeddings Dimensions",
    "cap_description": "Query the dimensionality of embeddings for a given model",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:model-spec;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--model-spec"
          }
        ],
        "arg_description": "Model spec to use for retrieving embeddings dimensions",
        "validation": {
          "pattern": ".*:.*",
          "min_length": 4,
          "max_length": 512
        },
        "default_value": "hf:sentence-transformers/all-MiniLM-L6-v2"
      }
    ],
    "output": {
      "media_urn": "media:integer;textable;numeric;scalar",
      "output_description": "Dimensionality of the embeddings (positive integer)",
      "validation": {
        "min": 1,
        "max": 100000
      }
    }
  },
  {
    "urn": {
      "tags": {
        "op": "generate_embeddings",
        "model_type": "candle",
        "in": "media:input-text;textable;scalar",
        "out": "media:embedding-vector;textable;keyed"
      }
    },
    "command": "generate_embeddings",
    "title": "Generate Vector Embeddings (Candle)",
    "cap_description": "Generate vector embeddings from text using Candle ML framework on CPU/GPU",
    "metadata": {},
    "media_specs": {
      "media:embedding-vector;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/embeddings",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "required": [
            "model_name",
            "embedding_dim",
            "total_chunks",
            "results"
          ],
          "properties": {
            "model_name": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the embedding model used"
            },
            "embedding_dim": {
              "type": "integer",
              "minimum": 1,
              "description": "Dimensionality of the embedding vectors"
            },
            "total_chunks": {
              "type": "integer",
              "minimum": 0,
              "description": "Total number of text chunks processed"
            },
            "results": {
              "type": "array",
              "description": "Array of embedding results for each chunk",
              "items": {
                "type": "object",
                "additionalProperties": false,
                "required": [
                  "chunk",
                  "embedding"
                ],
                "properties": {
                  "chunk": {
                    "type": "object",
                    "additionalProperties": false,
                    "required": [
                      "chunk_index",
                      "text",
                      "start_offset",
                      "end_offset"
                    ],
                    "properties": {
                      "chunk_index": {
                        "type": "integer",
                        "minimum": 0,
                        "description": "Index of this chunk"
                      },
                      "text": {
                        "type": "string",
                        "description": "The text content of this chunk"
                      },
                      "start_offset": {
                        "type": "integer",
                        "minimum": 0,
                        "description": "Start byte offset in original text"
                      },
                      "end_offset": {
                        "type": "integer",
                        "minimum": 0,
                        "description": "End byte offset in original text"
                      }
                    }
                  },
                  "embedding": {
                    "type": "array",
                    "items": {
                      "type": "number"
                    },
                    "description": "The embedding vector for this chunk"
                  }
                }
              }
            }
          }
        }
      }
    },
    "args": [
      {
        "media_urn": "media:input-text;textable;scalar",
        "required": false,
        "sources": [
          {
            "stdin": "media:input-text;textable;scalar"
          },
          {
            "cli_flag": "--text"
          }
        ],
        "arg_description": "Input text to generate embeddings for",
        "validation": {
          "min_length": 1,
          "max_length": 1000000
        }
      },
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--file"
          }
        ],
        "arg_description": "Path to input file to generate embeddings from",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:hf-model-name;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--model"
          }
        ],
        "arg_description": "HuggingFace model name for embeddings",
        "validation": {
          "min_length": 1,
          "max_length": 256
        },
        "default_value": "sentence-transformers/all-MiniLM-L6-v2"
      },
      {
        "media_urn": "media:chunk-size;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--chunk-size"
          }
        ],
        "arg_description": "Chunk size in words for splitting input text",
        "validation": {
          "min": 10,
          "max": 2000
        },
        "default_value": 400
      },
      {
        "media_urn": "media:chunk-overlap;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--chunk-overlap"
          }
        ],
        "arg_description": "Chunk overlap in words when splitting input text",
        "validation": {
          "min": 0,
          "max": 500
        },
        "default_value": 50
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Output JSON file path to write embeddings",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      }
    ],
    "output": {
      "media_urn": "media:embedding-vector;textable;keyed",
      "output_description": "JSON containing embeddings, chunk metadata and model information"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "generate_embeddings",
        "format": "gguf",
        "model_type": "gguf",
        "in": "media:input-text;textable;scalar",
        "out": "media:embedding-vector;textable;keyed"
      }
    },
    "command": "generate_embeddings",
    "title": "Generate Vector Embeddings (GGUF)",
    "cap_description": "Generate vector embeddings from text using GGUF models with llama.cpp backend",
    "metadata": {},
    "media_specs": {
      "media:embedding-vector;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/embeddings",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "required": [
            "success",
            "model_name",
            "embedding_dim",
            "total_chunks",
            "results"
          ],
          "properties": {
            "success": {
              "type": "boolean",
              "description": "Whether the embedding generation succeeded"
            },
            "model_name": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the embedding model used"
            },
            "embedding_dim": {
              "type": "integer",
              "minimum": 1,
              "description": "Dimensionality of the embedding vectors"
            },
            "total_chunks": {
              "type": "integer",
              "minimum": 0,
              "description": "Total number of text chunks processed"
            },
            "results": {
              "type": "array",
              "description": "Array of embedding results for each chunk",
              "items": {
                "type": "object",
                "additionalProperties": false,
                "required": [
                  "chunk",
                  "embedding"
                ],
                "properties": {
                  "chunk": {
                    "type": "object",
                    "additionalProperties": false,
                    "required": [
                      "chunk_index",
                      "text",
                      "start_offset",
                      "end_offset"
                    ],
                    "properties": {
                      "chunk_index": {
                        "type": "integer",
                        "minimum": 0,
                        "description": "Index of this chunk"
                      },
                      "text": {
                        "type": "string",
                        "description": "The text content of this chunk"
                      },
                      "start_offset": {
                        "type": "integer",
                        "minimum": 0,
                        "description": "Start byte offset in original text"
                      },
                      "end_offset": {
                        "type": "integer",
                        "minimum": 0,
                        "description": "End byte offset in original text"
                      }
                    }
                  },
                  "embedding": {
                    "type": "array",
                    "items": {
                      "type": "number"
                    },
                    "description": "The L2-normalized embedding vector for this chunk"
                  }
                }
              }
            }
          }
        }
      }
    },
    "args": [
      {
        "media_urn": "media:input-text;textable;scalar",
        "required": false,
        "sources": [
          {
            "stdin": "media:input-text;textable;scalar"
          },
          {
            "cli_flag": "--text"
          }
        ],
        "arg_description": "Input text to generate embeddings for",
        "validation": {
          "min_length": 1,
          "max_length": 1000000
        }
      },
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--file"
          }
        ],
        "arg_description": "Path to input file to generate embeddings from",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:model-spec;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--model-spec"
          }
        ],
        "arg_description": "GGUF model specification (HuggingFace repo or local path)",
        "validation": {
          "min_length": 1,
          "max_length": 512
        },
        "default_value": "hf:nomic-ai/nomic-embed-text-v1.5-GGUF"
      },
      {
        "media_urn": "media:chunk-size;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--chunk-size"
          }
        ],
        "arg_description": "Chunk size in words for splitting input text",
        "validation": {
          "min": 10,
          "max": 2000
        },
        "default_value": 400
      },
      {
        "media_urn": "media:chunk-overlap;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--chunk-overlap"
          }
        ],
        "arg_description": "Chunk overlap in words when splitting input text",
        "validation": {
          "min": 0,
          "max": 500
        },
        "default_value": 50
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Output JSON file path to write embeddings",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      }
    ],
    "output": {
      "media_urn": "media:embedding-vector;textable;keyed",
      "output_description": "JSON containing L2-normalized embeddings, chunk metadata and model information"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "generate_embeddings",
        "model_type": "mlx",
        "in": "media:mlx-model-path;textable;scalar",
        "out": "media:embedding-vector;textable;keyed"
      }
    },
    "command": "generate_embeddings",
    "title": "Generate Vector Embeddings (MLX)",
    "cap_description": "Generate vector embeddings from text using MLX-based models on Apple Silicon",
    "metadata": {},
    "media_specs": {
      "media:embedding-vector;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/embeddings",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "required": [
            "success",
            "model_name",
            "embedding_dim",
            "total_chunks",
            "results"
          ],
          "properties": {
            "success": {
              "type": "boolean",
              "description": "Whether the embedding generation succeeded"
            },
            "model_name": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the embedding model used"
            },
            "embedding_dim": {
              "type": "integer",
              "minimum": 1,
              "description": "Dimensionality of the embedding vectors"
            },
            "total_chunks": {
              "type": "integer",
              "minimum": 0,
              "description": "Total number of text chunks processed"
            },
            "results": {
              "type": "array",
              "description": "Array of embedding results for each chunk",
              "items": {
                "type": "object",
                "additionalProperties": false,
                "required": [
                  "chunk",
                  "embedding"
                ],
                "properties": {
                  "chunk": {
                    "type": "object",
                    "additionalProperties": false,
                    "required": [
                      "chunk_index",
                      "text",
                      "start_offset",
                      "end_offset"
                    ],
                    "properties": {
                      "chunk_index": {
                        "type": "integer",
                        "minimum": 0,
                        "description": "Index of this chunk"
                      },
                      "text": {
                        "type": "string",
                        "description": "The text content of this chunk"
                      },
                      "start_offset": {
                        "type": "integer",
                        "minimum": 0,
                        "description": "Start byte offset in original text"
                      },
                      "end_offset": {
                        "type": "integer",
                        "minimum": 0,
                        "description": "End byte offset in original text"
                      }
                    }
                  },
                  "embedding": {
                    "type": "array",
                    "items": {
                      "type": "number"
                    },
                    "description": "The embedding vector for this chunk"
                  }
                }
              }
            }
          }
        }
      }
    },
    "args": [
      {
        "media_urn": "media:mlx-model-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:mlx-model-path;textable;scalar"
          },
          {
            "cli_flag": "--model"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to MLX embedding model directory",
        "validation": {
          "min_length": 1
        }
      },
      {
        "media_urn": "media:input-text;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--text"
          }
        ],
        "arg_description": "Input text to generate embeddings for",
        "validation": {
          "min_length": 1,
          "max_length": 1000000
        }
      },
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--file"
          }
        ],
        "arg_description": "Path to input file to generate embeddings from",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:chunk-size;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--chunk-size"
          }
        ],
        "arg_description": "Chunk size in words for splitting input text",
        "validation": {
          "min": 10,
          "max": 2000
        },
        "default_value": 400
      },
      {
        "media_urn": "media:chunk-overlap;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--chunk-overlap"
          }
        ],
        "arg_description": "Chunk overlap in words when splitting input text",
        "validation": {
          "min": 0,
          "max": 500
        },
        "default_value": 50
      }
    ],
    "output": {
      "media_urn": "media:embedding-vector;textable;keyed",
      "output_description": "JSON containing embeddings, chunk metadata and model information"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "generate_embeddings",
        "in": "media:input-text;textable;scalar",
        "out": "media:embedding-vector;textable;keyed"
      }
    },
    "command": "generate_embeddings",
    "title": "Generate Vector Embeddings",
    "cap_description": "Generate vector embeddings from text or file input",
    "metadata": {},
    "media_specs": {
      "media:embedding-vector;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/embeddings",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "required": [
            "embeddings",
            "model_info",
            "total_chunks"
          ],
          "properties": {
            "embeddings": {
              "type": "array",
              "description": "Array of embedding chunks",
              "items": {
                "type": "object",
                "additionalProperties": false,
                "required": [
                  "text",
                  "vector",
                  "chunk_index"
                ],
                "properties": {
                  "text": {
                    "type": "string",
                    "description": "The text chunk that was embedded"
                  },
                  "vector": {
                    "type": "array",
                    "items": {
                      "type": "number"
                    },
                    "description": "The embedding vector"
                  },
                  "chunk_index": {
                    "type": "integer",
                    "minimum": 0,
                    "description": "Index of this chunk"
                  },
                  "start_position": {
                    "type": "integer",
                    "minimum": 0,
                    "description": "Start position in original text"
                  },
                  "end_position": {
                    "type": "integer",
                    "minimum": 0,
                    "description": "End position in original text"
                  }
                }
              }
            },
            "model_info": {
              "type": "object",
              "additionalProperties": false,
              "description": "Information about the model used",
              "required": [
                "model_name",
                "dimensions"
              ],
              "properties": {
                "model_name": {
                  "type": "string",
                  "minLength": 1,
                  "description": "Name of the embedding model"
                },
                "dimensions": {
                  "type": "integer",
                  "minimum": 1,
                  "description": "Dimensionality of the embeddings"
                },
                "max_sequence_length": {
                  "type": "integer",
                  "minimum": 1,
                  "description": "Maximum sequence length supported"
                }
              }
            },
            "metadata": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              },
              "description": "Additional metadata"
            },
            "total_chunks": {
              "type": "integer",
              "minimum": 0,
              "description": "Total number of chunks processed"
            },
            "processing_time_ms": {
              "type": "integer",
              "minimum": 0,
              "description": "Processing time in milliseconds"
            }
          }
        }
      }
    },
    "args": [
      {
        "media_urn": "media:input-text;textable;scalar",
        "required": false,
        "sources": [
          {
            "stdin": "media:input-text;textable;scalar"
          },
          {
            "cli_flag": "--text"
          }
        ],
        "arg_description": "Input text to generate embeddings for",
        "validation": {
          "min_length": 1,
          "max_length": 1000000
        }
      },
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--file-path"
          }
        ],
        "arg_description": "Path to input file to generate embeddings from",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "cli_flag": "--output"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Output JSON file path to write embeddings",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      },
      {
        "media_urn": "media:chunk-size;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--chunk-size"
          }
        ],
        "arg_description": "Chunk size in words for splitting input text",
        "validation": {
          "min": 1
        },
        "default_value": 400
      },
      {
        "media_urn": "media:chunk-overlap;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--chunk-overlap"
          }
        ],
        "arg_description": "Chunk overlap in words when splitting input text",
        "validation": {
          "min": 0
        },
        "default_value": 50
      },
      {
        "media_urn": "media:include-pattern;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--include"
          }
        ],
        "arg_description": "File include pattern (can be provided multiple times)"
      },
      {
        "media_urn": "media:exclude-pattern;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--exclude"
          }
        ],
        "arg_description": "File exclude pattern (can be provided multiple times)"
      },
      {
        "media_urn": "media:model-spec;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--model-spec"
          }
        ],
        "arg_description": "Model spec to use for embeddings generation",
        "validation": {
          "pattern": ".*:.*",
          "min_length": 4,
          "max_length": 512
        },
        "default_value": "hf:sentence-transformers/all-MiniLM-L6-v2"
      }
    ],
    "output": {
      "media_urn": "media:embedding-vector;textable;keyed",
      "output_description": "JSON file containing embeddings, chunk metadata and model information"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "extract_metadata",
        "in": "media:log;textable",
        "out": "media:file-metadata;textable;keyed"
      }
    },
    "command": "extract-metadata",
    "title": "Extract Log Document Metadata",
    "cap_description": "Extract log document metadata including title, file size, word count, and other properties",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:log;textable"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the log file to process",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Write output to specified file instead of stdout",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      }
    ],
    "output": {
      "media_urn": "media:object;textable;keyed",
      "output_description": "Structured metadata including file properties and log-specific metadata"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "extract_metadata",
        "in": "media:md;textable",
        "out": "media:file-metadata;textable;keyed"
      }
    },
    "command": "extract-metadata",
    "title": "Extract Markdown Document Metadata",
    "cap_description": "Extract markdown document metadata including title, file size, word count, and other properties",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:md;textable"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the markdown file to process",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Write output to specified file instead of stdout",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      }
    ],
    "output": {
      "media_urn": "media:object;textable;keyed",
      "output_description": "Structured metadata including file properties and markdown-specific metadata"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "extract_metadata",
        "in": "media:rst;textable",
        "out": "media:file-metadata;textable;keyed"
      }
    },
    "command": "extract-metadata",
    "title": "Extract RST Document Metadata",
    "cap_description": "Extract RST document metadata including title, file size, word count, and other properties",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:rst;textable"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the RST file to process",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Write output to specified file instead of stdout",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      }
    ],
    "output": {
      "media_urn": "media:object;textable;keyed",
      "output_description": "Structured metadata including file properties and RST-specific metadata"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "extract_metadata",
        "in": "media:txt;textable",
        "out": "media:file-metadata;textable;keyed"
      }
    },
    "command": "extract-metadata",
    "title": "Extract Text Document Metadata",
    "cap_description": "Extract text document metadata including title, file size, word count, and other properties",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:txt;textable"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the text file to process",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Write output to specified file instead of stdout",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      }
    ],
    "output": {
      "media_urn": "media:object;textable;keyed",
      "output_description": "Structured metadata including file properties and text-specific metadata"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "extract_metadata",
        "in": "media:pdf;binary",
        "out": "media:file-metadata;textable;keyed"
      }
    },
    "command": "extract-metadata",
    "title": "Extract Document Metadata",
    "cap_description": "Extract document metadata including title, author, creation date, file size, and other properties",
    "metadata": {},
    "media_specs": {
      "media:file-metadata;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/document-metadata",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "file_path": {
              "type": "string",
              "minLength": 1,
              "description": "Path to the source file"
            },
            "file_size_bytes": {
              "type": "integer",
              "minimum": 0,
              "description": "File size in bytes"
            },
            "content_length": {
              "type": "integer",
              "minimum": 0,
              "description": "Content length"
            },
            "mime_type": {
              "type": [
                "string",
                "null"
              ],
              "description": "MIME type of the file"
            },
            "encoding": {
              "type": [
                "string",
                "null"
              ],
              "description": "Document encoding"
            },
            "title": {
              "type": [
                "string",
                "null"
              ],
              "description": "Document title"
            },
            "subject": {
              "type": [
                "string",
                "null"
              ],
              "description": "Document subject"
            },
            "identifier": {
              "type": [
                "string",
                "null"
              ],
              "description": "Document identifier"
            },
            "language": {
              "type": [
                "string",
                "null"
              ],
              "description": "Document language"
            },
            "creator": {
              "type": [
                "string",
                "null"
              ],
              "description": "Application that created the document"
            },
            "producer": {
              "type": [
                "string",
                "null"
              ],
              "description": "Application that produced the PDF"
            },
            "authors": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Document authors list"
            },
            "contributors": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Document contributors"
            },
            "keywords": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Document keywords"
            },
            "creation_date": {
              "type": [
                "string",
                "null"
              ],
              "description": "Document creation date in any format"
            },
            "modification_date": {
              "type": [
                "string",
                "null"
              ],
              "description": "Document modification date in any format"
            },
            "page_count": {
              "type": [
                "integer",
                "null"
              ],
              "minimum": 0,
              "description": "Total number of pages"
            },
            "chapter_count": {
              "type": [
                "integer",
                "null"
              ],
              "minimum": 0,
              "description": "Number of chapters"
            },
            "word_count": {
              "type": [
                "integer",
                "null"
              ],
              "minimum": 0,
              "description": "Word count"
            },
            "character_count": {
              "type": [
                "integer",
                "null"
              ],
              "minimum": 0,
              "description": "Character count"
            },
            "document_type": {
              "type": "string",
              "description": "Type of document"
            },
            "format_version": {
              "type": [
                "string",
                "null"
              ],
              "description": "Format version"
            },
            "extended_metadata": {
              "type": "object",
              "additionalProperties": true,
              "description": "Additional metadata"
            },
            "pdf_version": {
              "type": [
                "string",
                "null"
              ],
              "description": "PDF version (e.g., '1.4')"
            },
            "has_forms": {
              "type": "boolean",
              "description": "Whether document has forms"
            },
            "is_encrypted": {
              "type": "boolean",
              "description": "Whether document is encrypted"
            },
            "attachment_count": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of attachments"
            },
            "is_linearized": {
              "type": "boolean",
              "description": "Whether PDF is linearized"
            },
            "epub_version": {
              "type": [
                "string",
                "null"
              ],
              "description": "EPUB version if applicable"
            },
            "publisher": {
              "type": [
                "string",
                "null"
              ],
              "description": "Document publisher"
            },
            "publication_date": {
              "type": [
                "string",
                "null"
              ],
              "description": "Publication date"
            },
            "rights": {
              "type": [
                "string",
                "null"
              ],
              "description": "Rights information"
            },
            "has_drm": {
              "type": "boolean",
              "description": "Whether document has DRM"
            },
            "thumbnail_path": {
              "type": [
                "string",
                "null"
              ],
              "description": "Path to thumbnail if generated"
            }
          },
          "required": [
            "file_path",
            "file_size_bytes",
            "content_length",
            "authors",
            "contributors",
            "keywords",
            "document_type",
            "extended_metadata",
            "has_forms",
            "is_encrypted",
            "attachment_count",
            "is_linearized",
            "has_drm"
          ]
        }
      }
    },
    "args": [
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:pdf;binary"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the document file to process",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Write output to specified file instead of stdout",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      }
    ],
    "output": {
      "media_urn": "media:file-metadata;textable;keyed",
      "output_description": "Structured metadata including file properties, document properties, and format-specific metadata"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "extract_outline",
        "in": "media:log;textable",
        "out": "media:document-outline;textable;keyed"
      }
    },
    "command": "extract-outline",
    "title": "Extract Log Document Outline",
    "cap_description": "Extract document outline/table of contents from log files",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:log;textable"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the log file to process",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:max-depth;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--max-depth"
          }
        ],
        "arg_description": "Maximum outline depth to extract (1-10)",
        "validation": {
          "min": 1,
          "max": 10
        }
      },
      {
        "media_urn": "media:include-order-indexes;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--include-order-indexes"
          }
        ],
        "arg_description": "Include page numbers in the outline",
        "default_value": true
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Write output to specified file instead of stdout",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      }
    ],
    "output": {
      "media_urn": "media:object;textable;keyed",
      "output_description": "Structured document outline with hierarchical entries"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "extract_outline",
        "in": "media:md;textable",
        "out": "media:document-outline;textable;keyed"
      }
    },
    "command": "extract-outline",
    "title": "Extract Markdown Document Outline",
    "cap_description": "Extract document outline/table of contents from markdown files",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:md;textable"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the markdown file to process",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:max-depth;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--max-depth"
          }
        ],
        "arg_description": "Maximum outline depth to extract (1-10)",
        "validation": {
          "min": 1,
          "max": 10
        }
      },
      {
        "media_urn": "media:include-order-indexes;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--include-order-indexes"
          }
        ],
        "arg_description": "Include page numbers in the outline",
        "default_value": true
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Write output to specified file instead of stdout",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      }
    ],
    "output": {
      "media_urn": "media:object;textable;keyed",
      "output_description": "Structured document outline with hierarchical entries"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "extract_outline",
        "in": "media:rst;textable",
        "out": "media:document-outline;textable;keyed"
      }
    },
    "command": "extract-outline",
    "title": "Extract RST Document Outline",
    "cap_description": "Extract document outline/table of contents from RST files",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:rst;textable"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the RST file to process",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:max-depth;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--max-depth"
          }
        ],
        "arg_description": "Maximum outline depth to extract (1-10)",
        "validation": {
          "min": 1,
          "max": 10
        }
      },
      {
        "media_urn": "media:include-order-indexes;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--include-order-indexes"
          }
        ],
        "arg_description": "Include page numbers in the outline",
        "default_value": true
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Write output to specified file instead of stdout",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      }
    ],
    "output": {
      "media_urn": "media:object;textable;keyed",
      "output_description": "Structured document outline with hierarchical entries"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "extract_outline",
        "in": "media:txt;textable",
        "out": "media:document-outline;textable;keyed"
      }
    },
    "command": "extract-outline",
    "title": "Extract Text Document Outline",
    "cap_description": "Extract document outline/table of contents from text files",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:txt;textable"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the text file to process",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:max-depth;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--max-depth"
          }
        ],
        "arg_description": "Maximum outline depth to extract (1-10)",
        "validation": {
          "min": 1,
          "max": 10
        }
      },
      {
        "media_urn": "media:include-order-indexes;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--include-order-indexes"
          }
        ],
        "arg_description": "Include page numbers in the outline",
        "default_value": true
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Write output to specified file instead of stdout",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      }
    ],
    "output": {
      "media_urn": "media:object;textable;keyed",
      "output_description": "Structured document outline with hierarchical entries"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "extract_outline",
        "in": "media:pdf;binary",
        "out": "media:document-outline;textable;keyed"
      }
    },
    "command": "extract-outline",
    "title": "Extract Document Outline",
    "cap_description": "Extract document outline/table of contents with hierarchical structure",
    "metadata": {},
    "media_specs": {
      "media:document-outline;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/document-outline",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "required": [
            "source_file",
            "document_type",
            "total_pages",
            "entries",
            "has_outline",
            "extraction_info"
          ],
          "properties": {
            "source_file": {
              "type": "string",
              "minLength": 1,
              "description": "Source file path"
            },
            "document_type": {
              "type": "string",
              "description": "Document format/type (PDF, EPUB, etc.)"
            },
            "total_pages": {
              "type": "integer",
              "minimum": 0,
              "description": "Total number of pages/sections in document"
            },
            "entries": {
              "type": "array",
              "description": "Root-level outline entries",
              "items": {
                "type": "object",
                "additionalProperties": false,
                "required": [
                  "title",
                  "level",
                  "children"
                ],
                "properties": {
                  "title": {
                    "type": "string",
                    "minLength": 1,
                    "description": "The title/label of this outline entry"
                  },
                  "level": {
                    "type": "integer",
                    "minimum": 0,
                    "description": "Hierarchical level (0 = top level, 1 = first sublevel, etc.)"
                  },
                  "page": {
                    "type": [
                      "integer",
                      "null"
                    ],
                    "minimum": 1,
                    "description": "Page/section number this entry points to (1-indexed)"
                  },
                  "source_ref": {
                    "type": [
                      "string",
                      "null"
                    ],
                    "description": "Optional source reference (filename, anchor, etc.)"
                  },
                  "children": {
                    "type": "array",
                    "description": "Child entries under this one"
                  }
                }
              }
            },
            "has_outline": {
              "type": "boolean",
              "description": "Whether this document has any outline/bookmarks"
            },
            "extraction_info": {
              "type": "object",
              "additionalProperties": false,
              "description": "Metadata about the extraction process",
              "required": [
                "extractor_name",
                "extractor_version",
                "warnings"
              ],
              "properties": {
                "extractor_name": {
                  "type": "string",
                  "description": "Tool that performed the extraction"
                },
                "extractor_version": {
                  "type": "string",
                  "description": "Version of the extraction tool"
                },
                "extracted_at": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "description": "Timestamp of extraction"
                },
                "warnings": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Any warnings or notes about the extraction"
                }
              }
            },
            "document_title": {
              "type": [
                "string",
                "null"
              ],
              "description": "Document title (from metadata if available)"
            }
          }
        }
      }
    },
    "args": [
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:pdf;binary"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the document file to process",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:max-depth;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--max-depth"
          }
        ],
        "arg_description": "Maximum outline depth to extract (1-10)",
        "validation": {
          "min": 1,
          "max": 10
        }
      },
      {
        "media_urn": "media:include-order-indexes;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--include-order-indexes"
          }
        ],
        "arg_description": "Include page numbers in the outline (default: true)",
        "default_value": true
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Write output to specified file instead of stdout",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      }
    ],
    "output": {
      "media_urn": "media:document-outline;textable;keyed",
      "output_description": "Hierarchical document outline with section titles and optional page numbers"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "generate_frontmatter_summary",
        "language": "en",
        "type": "constrained",
        "in": "media:frontmatter-text;textable;scalar",
        "out": "media:string;textable;scalar"
      }
    },
    "command": "generate_text",
    "title": "Summarize Frontmatter",
    "cap_description": "Extract and organize bibliographic information from book frontmatter text",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:frontmatter-text;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:frontmatter-text;textable;scalar"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Frontmatter text to process and summarize",
        "validation": {
          "min_length": 50,
          "max_length": 131072
        }
      },
      {
        "media_urn": "media:output-format;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--format"
          }
        ],
        "arg_description": "Output format for the summary",
        "validation": {
          "allowed_values": [
            "organized",
            "structured",
            "compact",
            "detailed"
          ]
        },
        "default_value": "organized"
      },
      {
        "media_urn": "media:preserve-all-data;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--preserve-all-data"
          }
        ],
        "arg_description": "Whether to preserve all factual information",
        "default_value": true
      },
      {
        "media_urn": "media:remove-boilerplate;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--remove-boilerplate"
          }
        ],
        "arg_description": "Whether to remove legal boilerplate and formatting chips",
        "default_value": true
      },
      {
        "media_urn": "media:language;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--language"
          }
        ],
        "arg_description": "Language of the frontmatter text",
        "validation": {
          "allowed_values": [
            "en",
            "es",
            "fr",
            "de",
            "it",
            "pt",
            "ru",
            "zh",
            "ja",
            "ko"
          ]
        },
        "default_value": "en"
      },
      {
        "media_urn": "media:max-tokens;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--max-tokens"
          }
        ],
        "arg_description": "Maximum tokens for summary output",
        "validation": {
          "min": 100,
          "max": 8192
        },
        "default_value": 2000
      },
      {
        "media_urn": "media:model-spec;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--model-spec"
          }
        ],
        "arg_description": "Model spec to use for summary generation",
        "validation": {
          "pattern": ".*:.*",
          "min_length": 4,
          "max_length": 512
        },
        "default_value": "hf:MaziyarPanahi/Mistral-7B-Instruct-v0.3-GGUF?include=*Q8_0*,*.json&exclude=*IQ1*,*IQ2*,*IQ3*,*Q2*,*Q3*"
      }
    ],
    "output": {
      "media_urn": "media:string;textable;scalar",
      "output_description": "Organized bibliographic summary with extracted metadata",
      "validation": {
        "min_length": 1,
        "max_length": 10000
      }
    }
  },
  {
    "urn": {
      "tags": {
        "op": "generate_thumbnail",
        "in": "media:log;textable",
        "out": "media:png;binary"
      }
    },
    "command": "generate-thumbnail",
    "title": "Generate Log Thumbnail",
    "cap_description": "Generate a thumbnail image preview of the log document",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:log;textable"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the log file to process",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:thumbnail-width;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--width"
          }
        ],
        "arg_description": "Width of the thumbnail in pixels",
        "validation": {
          "min": 50,
          "max": 2000
        },
        "default_value": 200
      },
      {
        "media_urn": "media:thumbnail-height;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--height"
          }
        ],
        "arg_description": "Height of the thumbnail in pixels",
        "validation": {
          "min": 50,
          "max": 2000
        },
        "default_value": 300
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Write thumbnail to specified file instead of stdout",
        "validation": {
          "pattern": "\\.(png|jpg|jpeg)$"
        }
      }
    ],
    "output": {
      "media_urn": "media:png;binary",
      "output_description": "PNG image data representing a thumbnail of the log document"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "generate_thumbnail",
        "in": "media:md;textable",
        "out": "media:png;binary"
      }
    },
    "command": "generate-thumbnail",
    "title": "Generate Markdown Thumbnail",
    "cap_description": "Generate a thumbnail image preview of the markdown document",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:md;textable"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the markdown file to process",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:thumbnail-width;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--width"
          }
        ],
        "arg_description": "Width of the thumbnail in pixels",
        "validation": {
          "min": 50,
          "max": 2000
        },
        "default_value": 200
      },
      {
        "media_urn": "media:thumbnail-height;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--height"
          }
        ],
        "arg_description": "Height of the thumbnail in pixels",
        "validation": {
          "min": 50,
          "max": 2000
        },
        "default_value": 300
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Write thumbnail to specified file instead of stdout",
        "validation": {
          "pattern": "\\.(png|jpg|jpeg)$"
        }
      }
    ],
    "output": {
      "media_urn": "media:png;binary",
      "output_description": "PNG image data representing a thumbnail of the markdown document"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "generate_thumbnail",
        "in": "media:pdf;binary",
        "out": "media:png;binary"
      }
    },
    "command": "generate-thumbnail",
    "title": "Generate PDF Thumbnail",
    "cap_description": "Generate a thumbnail image preview of the document",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:pdf;binary"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the document file to process",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:thumbnail-width;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--width"
          }
        ],
        "arg_description": "Width of the thumbnail in pixels",
        "validation": {
          "min": 50,
          "max": 2000
        },
        "default_value": 200
      },
      {
        "media_urn": "media:thumbnail-height;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--height"
          }
        ],
        "arg_description": "Height of the thumbnail in pixels",
        "validation": {
          "min": 50,
          "max": 2000
        },
        "default_value": 300
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Write thumbnail to specified file instead of stdout",
        "validation": {
          "pattern": "\\.(png|jpg|jpeg)$"
        }
      },
      {
        "media_urn": "media:index-range;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--index-range"
          }
        ],
        "arg_description": "Index Range to generate thumbnails from (1-based). Examples: '1' (single page), '1-5' (pages 1-5), '3-' (page 3 to end)",
        "validation": {
          "pattern": "^\\d+(-\\d*)?$"
        },
        "default_value": "1"
      }
    ],
    "output": {
      "media_urn": "media:png;binary",
      "output_description": "PNG image data representing a thumbnail of the document"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "generate_thumbnail",
        "in": "media:rst;textable",
        "out": "media:png;binary"
      }
    },
    "command": "generate-thumbnail",
    "title": "Generate RST Thumbnail",
    "cap_description": "Generate a thumbnail image preview of the RST document",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:rst;textable"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the RST file to process",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:thumbnail-width;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--width"
          }
        ],
        "arg_description": "Width of the thumbnail in pixels",
        "validation": {
          "min": 50,
          "max": 2000
        },
        "default_value": 200
      },
      {
        "media_urn": "media:thumbnail-height;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--height"
          }
        ],
        "arg_description": "Height of the thumbnail in pixels",
        "validation": {
          "min": 50,
          "max": 2000
        },
        "default_value": 300
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Write thumbnail to specified file instead of stdout",
        "validation": {
          "pattern": "\\.(png|jpg|jpeg)$"
        }
      }
    ],
    "output": {
      "media_urn": "media:png;binary",
      "output_description": "PNG image data representing a thumbnail of the RST document"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "generate_thumbnail",
        "in": "media:txt;textable",
        "out": "media:png;binary"
      }
    },
    "command": "generate-thumbnail",
    "title": "Generate Text Thumbnail",
    "cap_description": "Generate a thumbnail image preview of the text document",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:txt;textable"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the text file to process",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:thumbnail-width;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--width"
          }
        ],
        "arg_description": "Width of the thumbnail in pixels",
        "validation": {
          "min": 50,
          "max": 2000
        },
        "default_value": 200
      },
      {
        "media_urn": "media:thumbnail-height;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--height"
          }
        ],
        "arg_description": "Height of the thumbnail in pixels",
        "validation": {
          "min": 50,
          "max": 2000
        },
        "default_value": 300
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Write thumbnail to specified file instead of stdout",
        "validation": {
          "pattern": "\\.(png|jpg|jpeg)$"
        }
      }
    ],
    "output": {
      "media_urn": "media:png;binary",
      "output_description": "PNG image data representing a thumbnail of the text document"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "generate_thumbnail",
        "in": "media:raw;binary",
        "out": "media:png;binary"
      }
    },
    "command": "generate-thumbnail",
    "title": "Generate Thumbnail",
    "cap_description": "Generate a thumbnail image preview of the file",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:raw;binary"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the document file to process",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:thumbnail-width;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--width"
          }
        ],
        "arg_description": "Width of the thumbnail in pixels",
        "validation": {
          "min": 50,
          "max": 2000
        },
        "default_value": 200
      },
      {
        "media_urn": "media:thumbnail-height;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--height"
          }
        ],
        "arg_description": "Height of the thumbnail in pixels",
        "validation": {
          "min": 50,
          "max": 2000
        },
        "default_value": 300
      },
      {
        "media_urn": "media:index-range;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--index-range"
          }
        ],
        "arg_description": "Index Range to generate thumbnails from (1-based).",
        "validation": {
          "pattern": "^\\d+(-\\d*)?$"
        },
        "default_value": "1"
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Write thumbnail to specified file instead of stdout",
        "validation": {
          "pattern": "\\.(png|jpg|jpeg)$"
        }
      }
    ],
    "output": {
      "media_urn": "media:png;binary",
      "output_description": "PNG image data representing a thumbnail of the document"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "generate_caption",
        "model_type": "candle",
        "in": "media:png;binary",
        "out": "media:image-caption;textable;keyed"
      }
    },
    "command": "generate_caption",
    "title": "Generate Image Caption (Candle)",
    "cap_description": "Generate image captions using BLIP models with Candle ML framework",
    "metadata": {},
    "media_specs": {
      "media:image-caption;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/caption-output",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "required": [
            "model_name",
            "image_path",
            "caption"
          ],
          "properties": {
            "model_name": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the BLIP model used"
            },
            "image_path": {
              "type": "string",
              "description": "Path to the captioned image"
            },
            "caption": {
              "type": "string",
              "description": "Generated caption for the image"
            },
            "generation_time_ms": {
              "type": "integer",
              "minimum": 0,
              "description": "Caption generation time in milliseconds"
            }
          }
        }
      }
    },
    "args": [
      {
        "media_urn": "media:image-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "cli_flag": "--image"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the image file to caption",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:prompt-text;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--prompt"
          }
        ],
        "arg_description": "Optional prompt to guide the captioning",
        "validation": {
          "min_length": 1,
          "max_length": 512
        }
      },
      {
        "media_urn": "media:hf-model-name;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--model"
          }
        ],
        "arg_description": "BLIP model name from HuggingFace",
        "validation": {
          "min_length": 1,
          "max_length": 256
        },
        "default_value": "Salesforce/blip-image-captioning-large"
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Output JSON file path",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      }
    ],
    "output": {
      "media_urn": "media:image-caption;textable;keyed",
      "output_description": "Generated caption with model metadata"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "generate_image_embeddings",
        "model_type": "candle",
        "in": "media:png;binary",
        "out": "media:embedding-vector;textable;keyed"
      }
    },
    "command": "generate_image_embeddings",
    "title": "Generate Image Embeddings (Candle)",
    "cap_description": "Generate image embeddings using CLIP models with Candle ML framework",
    "metadata": {},
    "media_specs": {
      "media:embedding-vector;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/image-embeddings",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "required": [
            "model_name",
            "embedding_dim",
            "image_path",
            "embedding"
          ],
          "properties": {
            "model_name": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the CLIP model used"
            },
            "embedding_dim": {
              "type": "integer",
              "minimum": 1,
              "description": "Dimensionality of the embedding vector"
            },
            "image_path": {
              "type": "string",
              "description": "Path to the embedded image"
            },
            "embedding": {
              "type": "array",
              "items": {
                "type": "number"
              },
              "description": "The image embedding vector"
            },
            "generation_time_ms": {
              "type": "integer",
              "minimum": 0,
              "description": "Embedding generation time in milliseconds"
            }
          }
        }
      },
      "media:embedding-vector-batch;textable;keyed;sequence": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/image-embeddings-batch-output",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "required": [
            "model_name",
            "embedding_dim",
            "total_images",
            "results"
          ],
          "properties": {
            "model_name": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the CLIP model used"
            },
            "embedding_dim": {
              "type": "integer",
              "minimum": 1,
              "description": "Dimensionality of the embedding vectors"
            },
            "total_images": {
              "type": "integer",
              "minimum": 0,
              "description": "Total number of images processed"
            },
            "results": {
              "type": "array",
              "description": "Array of image embedding results",
              "items": {
                "type": "object",
                "additionalProperties": false,
                "required": [
                  "image_path",
                  "embedding"
                ],
                "properties": {
                  "image_path": {
                    "type": "string",
                    "description": "Path to the image"
                  },
                  "embedding": {
                    "type": "array",
                    "items": {
                      "type": "number"
                    },
                    "description": "The embedding vector"
                  }
                }
              }
            }
          }
        }
      }
    },
    "args": [
      {
        "media_urn": "media:image-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "cli_flag": "--image"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the image file to embed",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:hf-model-name;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--model"
          }
        ],
        "arg_description": "CLIP model name from HuggingFace",
        "validation": {
          "min_length": 1,
          "max_length": 256
        },
        "default_value": "openai/clip-vit-base-patch32"
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Output JSON file path",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      }
    ],
    "output": {
      "media_urn": "media:embedding-vector;textable;keyed",
      "output_description": "Image embedding vector with model metadata"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "codegeneration",
        "language": "en",
        "type": "constrained",
        "in": "media:prompt-text;textable;scalar",
        "out": "media:llm-inference-output;textable;keyed"
      }
    },
    "command": "llm_inference",
    "title": "Generate Code in English",
    "cap_description": "Code generation and programming tasks in English",
    "metadata": {},
    "media_specs": {
      "media:llm-inference-output;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/llm_inference-output",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "code": {
              "type": "string",
              "minLength": 1,
              "description": "The generated code"
            },
            "language": {
              "type": "string",
              "enum": [
                "rust",
                "python",
                "javascript",
                "typescript",
                "go",
                "java",
                "c",
                "cpp",
                "swift",
                "kotlin",
                "sql",
                "shell",
                "html",
                "css",
                "json",
                "yaml",
                "toml"
              ],
              "description": "Programming language used"
            },
            "tests": {
              "type": "string",
              "description": "Generated unit tests (if requested)"
            },
            "documentation": {
              "type": "string",
              "description": "Generated documentation"
            },
            "explanation": {
              "type": "string",
              "description": "Explanation of the code logic"
            },
            "dependencies": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Required dependencies or imports"
            },
            "complexity_score": {
              "type": "integer",
              "minimum": 1,
              "maximum": 10,
              "description": "Code complexity rating (1-10)"
            },
            "tokens_used": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of tokens consumed for generation"
            },
            "model_used": {
              "type": "string",
              "description": "Model that generated the code"
            },
            "generation_time_ms": {
              "type": "integer",
              "minimum": 0,
              "description": "Generation time in milliseconds"
            }
          },
          "required": [
            "code",
            "language"
          ]
        }
      }
    },
    "args": [
      {
        "media_urn": "media:prompt-text;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:prompt-text;textable;scalar"
          },
          {
            "cli_flag": "--prompt"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Code generation prompt or specification",
        "validation": {
          "min_length": 1,
          "max_length": 16384
        }
      },
      {
        "media_urn": "media:programming-language;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--language"
          }
        ],
        "arg_description": "Programming language for code generation",
        "validation": {
          "allowed_values": [
            "rust",
            "python",
            "javascript",
            "typescript",
            "go",
            "java",
            "c",
            "cpp",
            "swift",
            "kotlin",
            "sql",
            "shell",
            "html",
            "css",
            "json",
            "yaml",
            "toml"
          ]
        },
        "default_value": "rust"
      },
      {
        "media_urn": "media:code-context;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--context"
          }
        ],
        "arg_description": "Existing code context or codebase information",
        "validation": {
          "max_length": 65536
        }
      },
      {
        "media_urn": "media:coding-style;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--style"
          }
        ],
        "arg_description": "Coding style or framework preferences",
        "validation": {
          "max_length": 4096
        }
      },
      {
        "media_urn": "media:max-tokens;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--max-tokens"
          }
        ],
        "arg_description": "Maximum tokens for generated code",
        "validation": {
          "min": 100,
          "max": 8192
        },
        "default_value": 4096
      },
      {
        "media_urn": "media:include-tests-flag;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--include-tests"
          }
        ],
        "arg_description": "Whether to include unit tests",
        "default_value": false
      },
      {
        "media_urn": "media:include-comments-flag;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--include-comments"
          }
        ],
        "arg_description": "Whether to include code comments",
        "default_value": true
      },
      {
        "media_urn": "media:model-spec;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--model-spec"
          }
        ],
        "arg_description": "Model spec to use for code generation",
        "validation": {
          "pattern": ".*:.*",
          "min_length": 4,
          "max_length": 512
        },
        "default_value": "hf:MaziyarPanahi/Mistral-7B-Instruct-v0.3-GGUF?include=*Q8_0*,*.json&exclude=*IQ1*,*IQ2*,*IQ3*,*Q2*,*Q3*"
      }
    ],
    "output": {
      "media_urn": "media:llm-inference-output;textable;keyed",
      "output_description": "Generated code with optional tests and documentation"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "conversation",
        "language": "en",
        "type": "constrained",
        "in": "media:prompt-text;textable;scalar",
        "out": "media:llm-inference-output;textable;keyed"
      }
    },
    "command": "llm_inference",
    "title": "Converse in English",
    "cap_description": "Natural conversation and chat responses in English",
    "metadata": {},
    "media_specs": {
      "media:llm-inference-output;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/llm_inference-output",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "response": {
              "type": "string",
              "minLength": 1,
              "description": "The generated conversational response"
            },
            "conversation_id": {
              "type": "string",
              "description": "Unique identifier for this conversation"
            },
            "tokens_used": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of tokens consumed for generation"
            },
            "finish_reason": {
              "type": "string",
              "enum": [
                "stop",
                "length",
                "timeout"
              ],
              "description": "Why generation finished"
            },
            "model_used": {
              "type": "string",
              "description": "Model that generated the response"
            },
            "generation_time_ms": {
              "type": "integer",
              "minimum": 0,
              "description": "Generation time in milliseconds"
            },
            "context_length": {
              "type": "integer",
              "minimum": 0,
              "description": "Length of context provided"
            },
            "temperature_used": {
              "type": "number",
              "minimum": 0,
              "maximum": 2,
              "description": "Temperature setting used"
            }
          },
          "required": [
            "response"
          ]
        }
      }
    },
    "args": [
      {
        "media_urn": "media:prompt-text;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:prompt-text;textable;scalar"
          },
          {
            "cli_flag": "--prompt"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "User's conversational input",
        "validation": {
          "min_length": 1,
          "max_length": 32768
        }
      },
      {
        "media_urn": "media:conversation-context;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--context"
          }
        ],
        "arg_description": "Conversation context and history",
        "validation": {
          "max_length": 65536
        }
      },
      {
        "media_urn": "media:max-tokens;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--max-tokens"
          }
        ],
        "arg_description": "Maximum tokens to generate",
        "validation": {
          "min": 1,
          "max": 8192
        },
        "default_value": 2000
      },
      {
        "media_urn": "media:temperature;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--temperature"
          }
        ],
        "arg_description": "Sampling temperature for creativity vs consistency",
        "validation": {
          "min": 0,
          "max": 2
        },
        "default_value": 0.7
      },
      {
        "media_urn": "media:system-prompt;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--system-prompt"
          }
        ],
        "arg_description": "System instructions for conversation behavior",
        "validation": {
          "max_length": 8192
        }
      },
      {
        "media_urn": "media:model-spec;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--model-spec"
          }
        ],
        "arg_description": "Model spec to use for conversation",
        "validation": {
          "pattern": ".*:.*",
          "min_length": 4,
          "max_length": 512
        },
        "default_value": "hf:MaziyarPanahi/Mistral-7B-Instruct-v0.3-GGUF?include=*Q8_0*,*.json&exclude=*IQ1*,*IQ2*,*IQ3*,*Q2*,*Q3*"
      }
    ],
    "output": {
      "media_urn": "media:llm-inference-output;textable;keyed",
      "output_description": "Generated conversational response with context information"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "conversation",
        "language": "es",
        "type": "constrained",
        "in": "media:prompt-text;textable;scalar",
        "out": "media:llm-inference-output;textable;keyed"
      }
    },
    "command": "llm_inference",
    "title": "Converse in Spanish",
    "cap_description": "Conversacion natural y respuestas de chat en espanol",
    "metadata": {},
    "media_specs": {
      "media:llm-inference-output;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/llm_inference-output",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "respuesta": {
              "type": "string",
              "minLength": 1,
              "description": "La respuesta conversacional generada"
            },
            "id_conversacion": {
              "type": "string",
              "description": "Identificador unico para esta conversacion"
            },
            "tokens_usados": {
              "type": "integer",
              "minimum": 0,
              "description": "Numero de tokens consumidos para la generacion"
            },
            "razon_finalizacion": {
              "type": "string",
              "enum": [
                "stop",
                "length",
                "timeout"
              ],
              "description": "Por que termino la generacion"
            },
            "modelo_usado": {
              "type": "string",
              "description": "Modelo que genero la respuesta"
            },
            "tiempo_generacion_ms": {
              "type": "integer",
              "minimum": 0,
              "description": "Tiempo de generacion en milisegundos"
            },
            "longitud_contexto": {
              "type": "integer",
              "minimum": 0,
              "description": "Longitud del contexto proporcionado"
            },
            "temperatura_usada": {
              "type": "number",
              "minimum": 0,
              "maximum": 2,
              "description": "Configuracion de temperatura utilizada"
            }
          },
          "required": [
            "respuesta"
          ]
        }
      }
    },
    "args": [
      {
        "media_urn": "media:prompt-text;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:prompt-text;textable;scalar"
          },
          {
            "cli_flag": "--prompt"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Entrada conversacional del usuario",
        "validation": {
          "min_length": 1,
          "max_length": 32768
        }
      },
      {
        "media_urn": "media:conversation-context;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--context"
          }
        ],
        "arg_description": "Contexto e historial de conversacion",
        "validation": {
          "max_length": 65536
        }
      },
      {
        "media_urn": "media:max-tokens;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--max-tokens"
          }
        ],
        "arg_description": "Maximo de tokens a generar",
        "validation": {
          "min": 1,
          "max": 8192
        },
        "default_value": 2000
      },
      {
        "media_urn": "media:temperature;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--temperature"
          }
        ],
        "arg_description": "Temperatura de muestreo para creatividad vs consistencia",
        "validation": {
          "min": 0,
          "max": 2
        },
        "default_value": 0.7
      },
      {
        "media_urn": "media:system-prompt;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--system-prompt"
          }
        ],
        "arg_description": "Instrucciones del sistema para comportamiento conversacional",
        "validation": {
          "max_length": 8192
        }
      },
      {
        "media_urn": "media:model-spec;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--model-spec"
          }
        ],
        "arg_description": "Model spec a usar para la conversacion",
        "validation": {
          "pattern": ".*:.*",
          "min_length": 4,
          "max_length": 512
        },
        "default_value": "hf:MaziyarPanahi/Mistral-7B-Instruct-v0.3-GGUF?include=*Q8_0*,*.json&exclude=*IQ1*,*IQ2*,*IQ3*,*Q2*,*Q3*"
      }
    ],
    "output": {
      "media_urn": "media:llm-inference-output;textable;keyed",
      "output_description": "Respuesta conversacional generada con informacion de contexto"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "creative",
        "language": "en",
        "type": "constrained",
        "in": "media:prompt-text;textable;scalar",
        "out": "media:llm-inference-output;textable;keyed"
      }
    },
    "command": "llm_inference",
    "title": "Write Creatively in English",
    "cap_description": "Creative writing and content generation in English",
    "metadata": {},
    "media_specs": {
      "media:llm-inference-output;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/llm_inference-output",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "content": {
              "type": "string",
              "minLength": 1,
              "description": "The generated creative content"
            },
            "genre": {
              "type": "string",
              "enum": [
                "story",
                "poetry",
                "dialogue",
                "description",
                "screenplay",
                "essay",
                "other"
              ],
              "description": "Genre of creative content"
            },
            "word_count": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of words in generated content"
            },
            "creativity_score": {
              "type": "number",
              "minimum": 0,
              "maximum": 1,
              "description": "Assessed creativity level of output"
            },
            "themes": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Identified themes in the content"
            },
            "style_notes": {
              "type": "string",
              "description": "Notes about writing style used"
            },
            "tokens_used": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of tokens consumed"
            },
            "model_used": {
              "type": "string",
              "description": "Model that generated the content"
            }
          },
          "required": [
            "content",
            "word_count"
          ]
        }
      }
    },
    "args": [
      {
        "media_urn": "media:prompt-text;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:prompt-text;textable;scalar"
          },
          {
            "cli_flag": "--prompt"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Creative writing prompt or brief",
        "validation": {
          "min_length": 1,
          "max_length": 8192
        }
      },
      {
        "media_urn": "media:genre;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--genre"
          }
        ],
        "arg_description": "Genre or style of creative content",
        "validation": {
          "allowed_values": [
            "fiction",
            "poetry",
            "essay",
            "story",
            "dialogue",
            "script",
            "article",
            "blog",
            "marketing",
            "technical",
            "academic"
          ]
        },
        "default_value": "fiction"
      },
      {
        "media_urn": "media:tone;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--tone"
          }
        ],
        "arg_description": "Tone or mood for the creative content",
        "validation": {
          "allowed_values": [
            "formal",
            "casual",
            "humorous",
            "serious",
            "dramatic",
            "playful",
            "professional",
            "academic",
            "conversational"
          ]
        },
        "default_value": "conversational"
      },
      {
        "media_urn": "media:output-length;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--length"
          }
        ],
        "arg_description": "Desired length of creative output",
        "validation": {
          "allowed_values": [
            "short",
            "medium",
            "long",
            "extended"
          ]
        },
        "default_value": "medium"
      },
      {
        "media_urn": "media:creative-context;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--context"
          }
        ],
        "arg_description": "Background context or inspiration",
        "validation": {
          "max_length": 16384
        }
      },
      {
        "media_urn": "media:max-tokens;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--max-tokens"
          }
        ],
        "arg_description": "Maximum tokens for creative output",
        "validation": {
          "min": 100,
          "max": 8192
        },
        "default_value": 3000
      },
      {
        "media_urn": "media:creativity-level;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--creativity-level"
          }
        ],
        "arg_description": "Creativity level (0.0-1.0, higher = more creative)",
        "validation": {
          "min": 0,
          "max": 1
        },
        "default_value": 0.8
      },
      {
        "media_urn": "media:model-spec;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--model-spec"
          }
        ],
        "arg_description": "Model spec to use for creative writing",
        "validation": {
          "pattern": ".*:.*",
          "min_length": 4,
          "max_length": 512
        },
        "default_value": "hf:MaziyarPanahi/Mistral-7B-Instruct-v0.3-GGUF?include=*Q8_0*,*.json&exclude=*IQ1*,*IQ2*,*IQ3*,*Q2*,*Q3*"
      }
    ],
    "output": {
      "media_urn": "media:llm-inference-output;textable;keyed",
      "output_description": "Creative written content with metadata"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "multiplechoice",
        "language": "en",
        "type": "constrained",
        "in": "media:query-text;textable;scalar",
        "out": "media:llm-inference-output;textable;keyed"
      }
    },
    "command": "llm_inference",
    "title": "Answer Multiple Choice in English",
    "cap_description": "Logical reasoning and binary decision tasks in English",
    "metadata": {},
    "media_specs": {
      "media:llm-inference-output;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/llm_inference-output",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "decision": {
              "type": "string",
              "description": "The logical decision or choice made"
            },
            "confidence": {
              "type": "number",
              "minimum": 0,
              "maximum": 1,
              "description": "Confidence score for the decision"
            },
            "reasoning": {
              "type": "string",
              "description": "Explanation of the reasoning process"
            },
            "decision_type": {
              "type": "string",
              "enum": [
                "binary",
                "classification",
                "reasoning",
                "verification",
                "comparison"
              ],
              "description": "Type of decision made"
            },
            "evidence": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Key evidence points used"
            },
            "tokens_used": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of tokens consumed"
            },
            "model_used": {
              "type": "string",
              "description": "Model that made the decision"
            }
          },
          "required": [
            "decision",
            "confidence"
          ]
        }
      }
    },
    "args": [
      {
        "media_urn": "media:query-text;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:query-text;textable;scalar"
          },
          {
            "cli_flag": "--query"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Logical query or decision problem",
        "validation": {
          "min_length": 1,
          "max_length": 16384
        }
      },
      {
        "media_urn": "media:reasoning-context;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--context"
          }
        ],
        "arg_description": "Context and facts for logical reasoning",
        "validation": {
          "max_length": 32768
        }
      },
      {
        "media_urn": "media:decision-type;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--decision-type"
          }
        ],
        "arg_description": "Type of logical decision required",
        "validation": {
          "allowed_values": [
            "binary",
            "classification",
            "reasoning",
            "verification",
            "comparison"
          ]
        },
        "default_value": "binary"
      },
      {
        "media_urn": "media:max-tokens;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--max-tokens"
          }
        ],
        "arg_description": "Maximum tokens for reasoning output",
        "validation": {
          "min": 10,
          "max": 4096
        },
        "default_value": 1000
      },
      {
        "media_urn": "media:require-explanation-flag;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--require-explanation"
          }
        ],
        "arg_description": "Whether to include reasoning explanation",
        "default_value": true
      },
      {
        "media_urn": "media:model-spec;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--model-spec"
          }
        ],
        "arg_description": "Model spec to use for decision making",
        "validation": {
          "pattern": ".*:.*",
          "min_length": 4,
          "max_length": 512
        },
        "default_value": "hf:MaziyarPanahi/Mistral-7B-Instruct-v0.3-GGUF?include=*Q8_0*,*.json&exclude=*IQ1*,*IQ2*,*IQ3*,*Q2*,*Q3*"
      }
    ],
    "output": {
      "media_urn": "media:llm-inference-output;textable;keyed",
      "output_description": "Logical decision with reasoning explanation and confidence"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "summarization",
        "language": "en",
        "type": "constrained",
        "in": "media:input-text;textable;scalar",
        "out": "media:llm-inference-output;textable;keyed"
      }
    },
    "command": "llm_inference",
    "title": "Summarize in English",
    "cap_description": "Document and text summarization in English",
    "metadata": {},
    "media_specs": {
      "media:llm-inference-output;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/llm_inference-output",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "summary": {
              "type": "string",
              "minLength": 1,
              "description": "The generated summary text"
            },
            "summary_type": {
              "type": "string",
              "enum": [
                "extractive",
                "abstractive",
                "bullet_points",
                "executive",
                "detailed",
                "brief"
              ],
              "description": "Type of summary generated"
            },
            "compression_ratio": {
              "type": "number",
              "minimum": 0,
              "maximum": 1,
              "description": "Ratio of summary length to original length"
            },
            "original_length": {
              "type": "integer",
              "minimum": 0,
              "description": "Length of original text in characters"
            },
            "summary_length": {
              "type": "integer",
              "minimum": 0,
              "description": "Length of summary in characters"
            },
            "key_points": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Extracted key points from the text"
            },
            "tokens_used": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of tokens consumed for generation"
            },
            "model_used": {
              "type": "string",
              "description": "Model that generated the summary"
            },
            "generation_time_ms": {
              "type": "integer",
              "minimum": 0,
              "description": "Generation time in milliseconds"
            },
            "focus_area": {
              "type": "string",
              "description": "Focus area that was applied"
            }
          },
          "required": [
            "summary",
            "summary_type",
            "compression_ratio"
          ]
        }
      }
    },
    "args": [
      {
        "media_urn": "media:input-text;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:input-text;textable;scalar"
          },
          {
            "cli_flag": "--text"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Text content to summarize",
        "validation": {
          "min_length": 100,
          "max_length": 131072
        }
      },
      {
        "media_urn": "media:summary-type;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--summary-type"
          }
        ],
        "arg_description": "Type of summary to generate",
        "validation": {
          "allowed_values": [
            "extractive",
            "abstractive",
            "bullet_points",
            "executive",
            "detailed",
            "brief"
          ]
        },
        "default_value": "abstractive"
      },
      {
        "media_urn": "media:output-length;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--length"
          }
        ],
        "arg_description": "Desired summary length",
        "validation": {
          "allowed_values": [
            "brief",
            "medium",
            "detailed",
            "comprehensive"
          ]
        },
        "default_value": "medium"
      },
      {
        "media_urn": "media:summary-focus;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--focus"
          }
        ],
        "arg_description": "Summary focus area",
        "validation": {
          "allowed_values": [
            "main_points",
            "key_facts",
            "conclusions",
            "methodology",
            "results",
            "implications",
            "overview"
          ]
        },
        "default_value": "main_points"
      },
      {
        "media_urn": "media:summary-context;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--context"
          }
        ],
        "arg_description": "Additional context for summarization",
        "validation": {
          "max_length": 8192
        }
      },
      {
        "media_urn": "media:max-tokens;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--max-tokens"
          }
        ],
        "arg_description": "Maximum tokens for summary output",
        "validation": {
          "min": 50,
          "max": 4096
        },
        "default_value": 1000
      },
      {
        "media_urn": "media:preserve-structure-flag;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--preserve-structure"
          }
        ],
        "arg_description": "Whether to preserve document structure",
        "default_value": false
      },
      {
        "media_urn": "media:model-spec;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--model-spec"
          }
        ],
        "arg_description": "Model spec to use for summarization",
        "validation": {
          "pattern": ".*:.*",
          "min_length": 4,
          "max_length": 512
        },
        "default_value": "hf:MaziyarPanahi/Mistral-7B-Instruct-v0.3-GGUF?include=*Q8_0*,*.json&exclude=*IQ1*,*IQ2*,*IQ3*,*Q2*,*Q3*"
      }
    ],
    "output": {
      "media_urn": "media:llm-inference-output;textable;keyed",
      "output_description": "Summary with metadata including compression metrics"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "coerce",
        "target": "textable",
        "in": "media:keyed",
        "out": "media:textable;scalar"
      }
    },
    "command": "coerce",
    "title": "Coerce Keyed to Textable",
    "cap_description": "Convert any keyed structure to its textable representation",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:keyed",
        "required": true,
        "sources": [
          {
            "stdin": "media:keyed"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "The keyed structure to convert to textable"
      }
    ],
    "output": {
      "media_urn": "media:textable;scalar",
      "output_description": "Textable representation of the keyed structure (JSON)"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "generate_text",
        "type": "llm",
        "format": "gguf",
        "model_type": "gguf",
        "in": "media:prompt-text;textable;scalar",
        "out": "media:llm-inference-output;textable;keyed"
      }
    },
    "command": "run_inference",
    "title": "Generate Text with LLM (GGUF)",
    "cap_description": "Generate text using GGUF models with llama.cpp backend",
    "metadata": {},
    "media_specs": {
      "media:llm-inference-output;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/llm_inference-output",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "required": [
            "generated_text",
            "model_name",
            "tokens_generated"
          ],
          "properties": {
            "generated_text": {
              "type": "string",
              "description": "The generated text response"
            },
            "model_name": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the model used for generation"
            },
            "tokens_generated": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of tokens generated"
            },
            "generation_time_ms": {
              "type": "integer",
              "minimum": 0,
              "description": "Generation time in milliseconds"
            },
            "prompt_tokens": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of tokens in the prompt"
            },
            "finish_reason": {
              "type": "string",
              "enum": [
                "stop",
                "length",
                "interrupted"
              ],
              "description": "Why generation finished"
            }
          }
        }
      }
    },
    "args": [
      {
        "media_urn": "media:prompt-text;textable;scalar",
        "required": false,
        "sources": [
          {
            "stdin": "media:prompt-text;textable;scalar"
          },
          {
            "cli_flag": "--prompt"
          }
        ],
        "arg_description": "Input text prompt for generation",
        "validation": {
          "min_length": 1,
          "max_length": 65536
        }
      },
      {
        "media_urn": "media:file-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--file"
          }
        ],
        "arg_description": "Path to input file containing prompt",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:model-spec;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--model-spec"
          }
        ],
        "arg_description": "GGUF model specification (HuggingFace repo or local path)",
        "validation": {
          "min_length": 1,
          "max_length": 512
        }
      },
      {
        "media_urn": "media:max-tokens;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--max-tokens"
          }
        ],
        "arg_description": "Maximum number of tokens to generate",
        "validation": {
          "min": 1,
          "max": 8192
        },
        "default_value": 512
      },
      {
        "media_urn": "media:temperature;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--temperature"
          }
        ],
        "arg_description": "Sampling temperature (0.0-2.0)",
        "validation": {
          "min": 0,
          "max": 2
        },
        "default_value": 0.7
      },
      {
        "media_urn": "media:top-k;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--top-k"
          }
        ],
        "arg_description": "Top-k sampling parameter",
        "validation": {
          "min": 1,
          "max": 1000
        },
        "default_value": 40
      },
      {
        "media_urn": "media:top-p;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--top-p"
          }
        ],
        "arg_description": "Top-p (nucleus) sampling parameter",
        "validation": {
          "min": 0,
          "max": 1
        },
        "default_value": 0.9
      },
      {
        "media_urn": "media:min-p;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--min-p"
          }
        ],
        "arg_description": "Min-p sampling parameter",
        "validation": {
          "min": 0,
          "max": 1
        },
        "default_value": 0.05
      },
      {
        "media_urn": "media:seed;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--seed"
          }
        ],
        "arg_description": "Random seed for reproducibility",
        "validation": {
          "min": 0,
          "max": 4294967295
        },
        "default_value": 42
      },
      {
        "media_urn": "media:max-context-length;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--max-context-length"
          }
        ],
        "arg_description": "Maximum context length",
        "validation": {
          "min": 512,
          "max": 131072
        },
        "default_value": 4096
      },
      {
        "media_urn": "media:batch-size;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--batch-size"
          }
        ],
        "arg_description": "Batch size for processing",
        "validation": {
          "min": 1,
          "max": 8192
        },
        "default_value": 2048
      },
      {
        "media_urn": "media:stream-flag;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--stream"
          }
        ],
        "arg_description": "Enable streaming output",
        "default_value": false
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Output JSON file path",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      }
    ],
    "output": {
      "media_urn": "media:llm-inference-output;textable;keyed",
      "output_description": "Generated text with metadata including tokens and timing"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "generate_text",
        "type": "llm",
        "model_type": "mlx",
        "in": "media:mlx-model-path;textable;scalar",
        "out": "media:llm-inference-output;textable;keyed"
      }
    },
    "command": "run_inference",
    "title": "Generate Text with LLM (MLX)",
    "cap_description": "Generate text using MLX-based LLM models on Apple Silicon",
    "metadata": {},
    "media_specs": {
      "media:llm-inference-output;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/llm_inference-output",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "required": [
            "success",
            "generated_text",
            "model_name",
            "tokens_generated"
          ],
          "properties": {
            "success": {
              "type": "boolean",
              "description": "Whether generation succeeded"
            },
            "generated_text": {
              "type": "string",
              "description": "The generated text response"
            },
            "model_name": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the model used for generation"
            },
            "tokens_generated": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of tokens generated"
            },
            "generation_time_ms": {
              "type": "number",
              "minimum": 0,
              "description": "Generation time in milliseconds"
            },
            "prompt_tokens": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of tokens in the prompt"
            },
            "finish_reason": {
              "type": "string",
              "enum": [
                "stop",
                "length"
              ],
              "description": "Why generation finished"
            }
          }
        }
      }
    },
    "args": [
      {
        "media_urn": "media:mlx-model-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:mlx-model-path;textable;scalar"
          },
          {
            "cli_flag": "--model"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to MLX model directory or HuggingFace model ID",
        "validation": {
          "min_length": 1
        }
      },
      {
        "media_urn": "media:prompt-text;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--prompt"
          }
        ],
        "arg_description": "Input text prompt for generation",
        "validation": {
          "min_length": 1,
          "max_length": 65536
        }
      },
      {
        "media_urn": "media:max-tokens;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--max-tokens"
          }
        ],
        "arg_description": "Maximum number of tokens to generate",
        "validation": {
          "min": 1,
          "max": 8192
        },
        "default_value": 512
      },
      {
        "media_urn": "media:temperature;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--temperature"
          }
        ],
        "arg_description": "Sampling temperature (0.0-2.0)",
        "validation": {
          "min": 0,
          "max": 2
        },
        "default_value": 0.7
      },
      {
        "media_urn": "media:top-p;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--top-p"
          }
        ],
        "arg_description": "Top-p (nucleus) sampling parameter",
        "validation": {
          "min": 0,
          "max": 1
        },
        "default_value": 0.9
      },
      {
        "media_urn": "media:repetition-penalty;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--repetition-penalty"
          }
        ],
        "arg_description": "Repetition penalty",
        "validation": {
          "min": 1,
          "max": 2
        },
        "default_value": 1.1
      },
      {
        "media_urn": "media:seed;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--seed"
          }
        ],
        "arg_description": "Random seed for reproducibility",
        "validation": {
          "min": 0,
          "max": 4294967295
        }
      },
      {
        "media_urn": "media:stream-flag;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--stream"
          }
        ],
        "arg_description": "Enable streaming output",
        "default_value": false
      }
    ],
    "output": {
      "media_urn": "media:llm-inference-output;textable;keyed",
      "output_description": "Generated text with metadata including tokens and timing"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "model-contents",
        "in": "media:void",
        "out": "media:model-contents;textable;keyed"
      }
    },
    "command": "inspect_contents",
    "title": "Inspect Model Contents",
    "cap_description": "Inspect the contents and structure of a model",
    "metadata": {},
    "media_specs": {
      "media:model-contents;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/contents-output",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "required": [
            "model_name",
            "files",
            "total_size_bytes",
            "inspection_depth"
          ],
          "properties": {
            "model_name": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the inspected model"
            },
            "model_type": {
              "type": "string",
              "description": "Type/architecture of the model"
            },
            "files": {
              "type": "array",
              "description": "List of files in the model",
              "items": {
                "type": "object",
                "additionalProperties": false,
                "required": [
                  "name",
                  "size_bytes"
                ],
                "properties": {
                  "name": {
                    "type": "string",
                    "minLength": 1,
                    "description": "File name"
                  },
                  "path": {
                    "type": "string",
                    "description": "File path within model"
                  },
                  "size_bytes": {
                    "type": "integer",
                    "minimum": 0,
                    "description": "File size in bytes"
                  },
                  "type": {
                    "type": "string",
                    "description": "File type or role"
                  },
                  "checksum": {
                    "type": "string",
                    "description": "File checksum"
                  }
                }
              }
            },
            "parameters": {
              "type": "object",
              "additionalProperties": false,
              "description": "Model parameter information",
              "properties": {
                "total_params": {
                  "type": "integer",
                  "minimum": 0,
                  "description": "Total number of parameters"
                },
                "trainable_params": {
                  "type": "integer",
                  "minimum": 0,
                  "description": "Number of trainable parameters"
                },
                "non_trainable_params": {
                  "type": "integer",
                  "minimum": 0,
                  "description": "Number of non-trainable parameters"
                },
                "dtype": {
                  "type": "string",
                  "description": "Parameter data type"
                }
              }
            },
            "layers": {
              "type": "array",
              "description": "Model layer information (if depth=detailed)",
              "items": {
                "type": "object",
                "additionalProperties": false,
                "required": [
                  "name",
                  "type"
                ],
                "properties": {
                  "name": {
                    "type": "string",
                    "minLength": 1,
                    "description": "Layer name"
                  },
                  "type": {
                    "type": "string",
                    "description": "Layer type"
                  },
                  "parameters": {
                    "type": "integer",
                    "minimum": 0,
                    "description": "Number of parameters in layer"
                  },
                  "output_shape": {
                    "type": "array",
                    "items": {
                      "type": "integer"
                    },
                    "description": "Output tensor shape"
                  }
                }
              }
            },
            "total_size_bytes": {
              "type": "integer",
              "minimum": 0,
              "description": "Total model size in bytes"
            },
            "format": {
              "type": "string",
              "description": "Model format (e.g., 'pytorch', 'onnx', 'safetensors')"
            },
            "inspection_depth": {
              "type": "string",
              "enum": [
                "summary",
                "detailed",
                "full"
              ],
              "description": "Depth of inspection performed"
            }
          }
        }
      }
    },
    "args": [
      {
        "media_urn": "media:model-id;textable;scalar",
        "required": true,
        "sources": [
          {
            "cli_flag": "--model"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Model identifier to inspect",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:inspection-depth;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--depth"
          }
        ],
        "arg_description": "Level of detail for contents inspection",
        "validation": {
          "allowed_values": [
            "summary",
            "detailed",
            "full"
          ]
        },
        "default_value": "summary"
      },
      {
        "media_urn": "media:output-format;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--format"
          }
        ],
        "arg_description": "Output format",
        "validation": {
          "allowed_values": [
            "json",
            "text",
            "tree"
          ]
        },
        "default_value": "json"
      }
    ],
    "output": {
      "media_urn": "media:model-contents;textable;keyed",
      "output_description": "Model contents including files, layers, parameters and metadata"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "download-model",
        "in": "media:void",
        "out": "media:download-result;textable;keyed"
      }
    },
    "command": "download",
    "title": "Download Model",
    "cap_description": "Download machine learning models from various repositories",
    "metadata": {},
    "media_specs": {
      "media:download-result;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/download-output",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "success": {
              "type": "boolean",
              "description": "Whether the download was successful"
            },
            "model_name": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the downloaded model"
            },
            "local_path": {
              "type": "string",
              "minLength": 1,
              "description": "Local path where the model was saved"
            },
            "size_bytes": {
              "type": "integer",
              "minimum": 0,
              "description": "Size of the downloaded model in bytes"
            },
            "download_time_ms": {
              "type": "integer",
              "minimum": 0,
              "description": "Download time in milliseconds"
            },
            "repository": {
              "type": "string",
              "description": "Repository the model was downloaded from"
            },
            "version": {
              "type": "string",
              "description": "Model version"
            },
            "checksum": {
              "type": "string",
              "description": "File checksum for verification"
            }
          },
          "required": [
            "success",
            "model_name"
          ]
        }
      }
    },
    "args": [
      {
        "media_urn": "media:model-id;textable;scalar",
        "required": true,
        "sources": [
          {
            "cli_flag": "--model"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Model identifier to download",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:repository;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--repository"
          }
        ],
        "arg_description": "Repository to download from",
        "validation": {
          "allowed_values": [
            "huggingface",
            "local",
            "custom"
          ]
        },
        "default_value": "huggingface"
      },
      {
        "media_urn": "media:force-flag;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--force"
          }
        ],
        "arg_description": "Force download even if model exists",
        "default_value": false
      },
      {
        "media_urn": "media:cache-dir;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--cache-dir"
          }
        ],
        "arg_description": "Custom cache directory for model storage",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      }
    ],
    "output": {
      "media_urn": "media:download-result;textable;keyed",
      "output_description": "Download result with model path and metadata"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "list-models",
        "in": "media:void",
        "out": "media:list-output;textable;keyed"
      }
    },
    "command": "list",
    "title": "List Models",
    "cap_description": "List available models and their status",
    "metadata": {},
    "media_specs": {
      "media:list-output;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/list-output",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "required": [
            "models",
            "total_count"
          ],
          "properties": {
            "models": {
              "type": "array",
              "description": "Array of model information",
              "items": {
                "type": "object",
                "additionalProperties": false,
                "required": [
                  "name",
                  "status"
                ],
                "properties": {
                  "name": {
                    "type": "string",
                    "minLength": 1,
                    "description": "Model name or identifier"
                  },
                  "status": {
                    "type": "string",
                    "enum": [
                      "loaded",
                      "available",
                      "downloading",
                      "cached"
                    ],
                    "description": "Current model status"
                  },
                  "size_bytes": {
                    "type": "integer",
                    "minimum": 0,
                    "description": "Model size in bytes"
                  },
                  "version": {
                    "type": "string",
                    "description": "Model version"
                  },
                  "repository": {
                    "type": "string",
                    "description": "Source repository"
                  },
                  "description": {
                    "type": "string",
                    "description": "Model description"
                  },
                  "last_accessed": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Last access time"
                  }
                }
              }
            },
            "total_count": {
              "type": "integer",
              "minimum": 0,
              "description": "Total number of models"
            },
            "filter_applied": {
              "type": "string",
              "description": "Filter that was applied"
            }
          }
        }
      }
    },
    "args": [
      {
        "media_urn": "media:filter-pattern;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--filter"
          }
        ],
        "arg_description": "Filter models by pattern",
        "validation": {
          "pattern": "^[^\\0]*$"
        }
      },
      {
        "media_urn": "media:model-status;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--status"
          }
        ],
        "arg_description": "Filter by model status",
        "validation": {
          "allowed_values": [
            "loaded",
            "available",
            "downloading",
            "cached",
            "all"
          ]
        }
      },
      {
        "media_urn": "media:output-format;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--format"
          }
        ],
        "arg_description": "Output format",
        "validation": {
          "allowed_values": [
            "json",
            "text",
            "table"
          ]
        },
        "default_value": "json"
      }
    ],
    "output": {
      "media_urn": "media:list-output;textable;keyed",
      "output_description": "List of models with their metadata and status"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "load-model",
        "in": "media:void",
        "out": "media:load-output;textable;keyed"
      }
    },
    "command": "load",
    "title": "Load Model",
    "cap_description": "Load a model into memory for inference operations",
    "metadata": {},
    "media_specs": {
      "media:load-output;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/load-output",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "success": {
              "type": "boolean",
              "description": "Whether the model was loaded successfully"
            },
            "model_name": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the loaded model"
            },
            "model_handle": {
              "type": "string",
              "description": "Handle/ID for the loaded model instance"
            },
            "device": {
              "type": "string",
              "enum": [
                "cpu",
                "cuda",
                "mps"
              ],
              "description": "Device the model was loaded on"
            },
            "precision": {
              "type": "string",
              "enum": [
                "float32",
                "float16",
                "int8",
                "int4"
              ],
              "description": "Model precision"
            },
            "memory_usage_mb": {
              "type": "integer",
              "minimum": 0,
              "description": "Memory usage in megabytes"
            },
            "load_time_ms": {
              "type": "integer",
              "minimum": 0,
              "description": "Load time in milliseconds"
            },
            "model_config": {
              "type": "object",
              "additionalProperties": true,
              "description": "Model configuration parameters"
            }
          },
          "required": [
            "success",
            "model_name"
          ]
        }
      }
    },
    "args": [
      {
        "media_urn": "media:model-id;textable;scalar",
        "required": true,
        "sources": [
          {
            "cli_flag": "--model"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Model identifier or path to load",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:device;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--device"
          }
        ],
        "arg_description": "Device to load model on",
        "validation": {
          "allowed_values": [
            "cpu",
            "cuda",
            "mps",
            "auto"
          ]
        },
        "default_value": "cpu"
      },
      {
        "media_urn": "media:precision;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--precision"
          }
        ],
        "arg_description": "Model precision/quantization level",
        "validation": {
          "allowed_values": [
            "float32",
            "float16",
            "int8",
            "int4"
          ]
        },
        "default_value": "float32"
      }
    ],
    "output": {
      "media_urn": "media:load-output;textable;keyed",
      "output_description": "Load result with model handle and configuration"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "model-management",
        "in": "media:void",
        "out": "media:manage-output;textable;keyed"
      }
    },
    "command": "manage",
    "title": "Manage Model",
    "cap_description": "General model management operations including installation, configuration and lifecycle",
    "metadata": {},
    "media_specs": {
      "media:manage-output;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/manage-output",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "success": {
              "type": "boolean",
              "description": "Whether the operation was successful"
            },
            "operation": {
              "type": "string",
              "enum": [
                "init",
                "config",
                "validate",
                "cleanup",
                "info"
              ],
              "description": "Operation that was performed"
            },
            "model_name": {
              "type": "string",
              "description": "Model that was operated on (if applicable)"
            },
            "message": {
              "type": "string",
              "description": "Human-readable result message"
            },
            "details": {
              "type": "object",
              "additionalProperties": true,
              "description": "Operation-specific details"
            },
            "execution_time_ms": {
              "type": "integer",
              "minimum": 0,
              "description": "Operation execution time in milliseconds"
            },
            "warnings": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Any warnings generated during operation"
            },
            "errors": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Any errors encountered during operation"
            }
          },
          "required": [
            "success",
            "operation",
            "message"
          ]
        }
      }
    },
    "args": [
      {
        "media_urn": "media:management-operation;textable;scalar",
        "required": true,
        "sources": [
          {
            "cli_flag": "--operation"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Management operation to perform",
        "validation": {
          "allowed_values": [
            "init",
            "config",
            "validate",
            "cleanup",
            "info"
          ]
        }
      },
      {
        "media_urn": "media:model-id;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--model"
          }
        ],
        "arg_description": "Model identifier or path",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      },
      {
        "media_urn": "media:output-format;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--format"
          }
        ],
        "arg_description": "Output format for information display",
        "validation": {
          "allowed_values": [
            "json",
            "text",
            "yaml"
          ]
        },
        "default_value": "json"
      }
    ],
    "output": {
      "media_urn": "media:manage-output;textable;keyed",
      "output_description": "Management operation result with status and details"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "model-status",
        "in": "media:void",
        "out": "media:status-output;textable;keyed"
      }
    },
    "command": "check_model_status",
    "title": "Check Model Status",
    "cap_description": "Check the status and health of a specific model",
    "metadata": {},
    "media_specs": {
      "media:status-output;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/status-output",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "model_name": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the model"
            },
            "status": {
              "type": "string",
              "enum": [
                "loaded",
                "available",
                "downloading",
                "cached",
                "error"
              ],
              "description": "Current model status"
            },
            "health": {
              "type": "string",
              "enum": [
                "healthy",
                "degraded",
                "unhealthy",
                "unknown"
              ],
              "description": "Model health status"
            },
            "is_loaded": {
              "type": "boolean",
              "description": "Whether the model is currently loaded in memory"
            },
            "memory_usage_mb": {
              "type": "integer",
              "minimum": 0,
              "description": "Current memory usage in megabytes"
            },
            "load_time": {
              "type": "string",
              "format": "date-time",
              "description": "When the model was loaded"
            },
            "last_used": {
              "type": "string",
              "format": "date-time",
              "description": "Last time the model was used"
            },
            "usage_count": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of times the model has been used"
            },
            "average_response_time_ms": {
              "type": "number",
              "minimum": 0,
              "description": "Average response time in milliseconds"
            },
            "error_message": {
              "type": "string",
              "description": "Error message if status is 'error'"
            },
            "configuration": {
              "type": "object",
              "additionalProperties": true,
              "description": "Model configuration (if detailed=true)"
            }
          },
          "required": [
            "model_name",
            "status",
            "health",
            "is_loaded"
          ]
        }
      }
    },
    "args": [
      {
        "media_urn": "media:model-id;textable;scalar",
        "required": true,
        "sources": [
          {
            "cli_flag": "--model"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Model identifier to check status for",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:detailed-flag;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--detailed"
          }
        ],
        "arg_description": "Include detailed diagnostics and metrics",
        "default_value": false
      },
      {
        "media_urn": "media:output-format;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--format"
          }
        ],
        "arg_description": "Output format",
        "validation": {
          "allowed_values": [
            "json",
            "text"
          ]
        },
        "default_value": "json"
      }
    ],
    "output": {
      "media_urn": "media:status-output;textable;keyed",
      "output_description": "Model status including health, performance metrics and configuration"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "unload-model",
        "in": "media:void",
        "out": "media:unload-output;textable;keyed"
      }
    },
    "command": "unload",
    "title": "Unload Model",
    "cap_description": "Unload a model from memory to free resources",
    "metadata": {},
    "media_specs": {
      "media:unload-output;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/unload-output",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "success": {
              "type": "boolean",
              "description": "Whether the model was unloaded successfully"
            },
            "model_name": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the unloaded model"
            },
            "freed_memory_mb": {
              "type": "integer",
              "minimum": 0,
              "description": "Memory freed in megabytes"
            },
            "unload_time_ms": {
              "type": "integer",
              "minimum": 0,
              "description": "Unload time in milliseconds"
            },
            "was_forced": {
              "type": "boolean",
              "description": "Whether the unload was forced"
            },
            "message": {
              "type": "string",
              "description": "Additional status message"
            }
          },
          "required": [
            "success",
            "model_name"
          ]
        }
      }
    },
    "args": [
      {
        "media_urn": "media:model-id;textable;scalar",
        "required": true,
        "sources": [
          {
            "cli_flag": "--model"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Model identifier or handle to unload",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:force-flag;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--force"
          }
        ],
        "arg_description": "Force unload even if model is in use",
        "default_value": false
      }
    ],
    "output": {
      "media_urn": "media:unload-output;textable;keyed",
      "output_description": "Unload result with status and freed resources"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "coerce",
        "target": "textable",
        "in": "media:numeric;scalar",
        "out": "media:textable;scalar"
      }
    },
    "command": "coerce",
    "title": "Coerce Numeric Scalar to Textable",
    "cap_description": "Convert any numeric scalar value to its textable representation",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:numeric;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:numeric;scalar"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "The numeric scalar value to convert"
      }
    ],
    "output": {
      "media_urn": "media:textable;scalar",
      "output_description": "Textable representation of the numeric value"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "query_structured",
        "language": "en",
        "type": "constrained",
        "in": "media:object;textable;keyed",
        "out": "media:json;textable;keyed"
      }
    },
    "command": "structured_query",
    "title": "Execute Structured Query",
    "cap_description": "Execute structured queries with JSON schema constraints and template rendering",
    "metadata": {},
    "media_specs": {
      "media:json;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/structured-query-output",
        "schema": {
          "type": [
            "object",
            "array",
            "string",
            "number",
            "boolean",
            "null"
          ],
          "description": "Raw JSON result from query execution - schema varies by specific query"
        }
      }
    },
    "args": [
      {
        "media_urn": "media:query-name;textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:object;textable;keyed"
          },
          {
            "cli_flag": "--query-name"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Name of the structured query to execute",
        "validation": {
          "min_length": 1,
          "max_length": 128,
          "pattern": "^[a-zA-Z0-9_-]+$"
        }
      },
      {
        "media_urn": "media:substitutions;textable;keyed",
        "required": true,
        "sources": [
          {
            "cli_flag": "--substitutions"
          },
          {
            "position": 1
          }
        ],
        "arg_description": "Template substitutions for the query prompt"
      },
      {
        "media_urn": "media:language-code;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--language"
          }
        ],
        "arg_description": "Language code for the query processing",
        "validation": {
          "allowed_values": [
            "en",
            "es",
            "fr",
            "de",
            "it",
            "pt",
            "ru",
            "zh",
            "ja",
            "ko"
          ]
        },
        "default_value": "en"
      },
      {
        "media_urn": "media:schema-variables;textable;keyed",
        "required": false,
        "sources": [
          {
            "cli_flag": "--schema-variables"
          }
        ],
        "arg_description": "Variables for dynamic schema generation",
        "default_value": {}
      },
      {
        "media_urn": "media:callback-enabled-flag;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--callback"
          }
        ],
        "arg_description": "Whether to enable streaming callback updates",
        "default_value": false
      },
      {
        "media_urn": "media:model-spec;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--model-spec"
          }
        ],
        "arg_description": "Model spec to use for structured query execution",
        "validation": {
          "pattern": ".*:.*",
          "min_length": 4,
          "max_length": 512
        },
        "default_value": "hf:MaziyarPanahi/Mistral-7B-Instruct-v0.3-GGUF?include=*Q8_0*,*.json&exclude=*IQ1*,*IQ2*,*IQ3*,*Q2*,*Q3*"
      }
    ],
    "output": {
      "media_urn": "media:json;textable;keyed",
      "output_description": "Structured JSON response conforming to the query's schema"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "coerce",
        "target": "keyed",
        "in": "media:scalar",
        "out": "media:textable;keyed"
      }
    },
    "command": "coerce",
    "title": "Coerce Scalar to Keyed",
    "cap_description": "Wrap any scalar value in a keyed structure",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:scalar"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "The scalar value to wrap in a keyed structure"
      }
    ],
    "output": {
      "media_urn": "media:textable;keyed",
      "output_description": "Keyed structure containing the scalar value"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "coerce",
        "target": "textable",
        "in": "media:sequence",
        "out": "media:textable;scalar"
      }
    },
    "command": "coerce",
    "title": "Coerce Sequence to Textable",
    "cap_description": "Convert any sequence to its textable representation",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:sequence",
        "required": true,
        "sources": [
          {
            "stdin": "media:sequence"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "The sequence to convert to textable"
      }
    ],
    "output": {
      "media_urn": "media:textable;scalar",
      "output_description": "Textable representation of the sequence (JSON array)"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "coerce",
        "target": "numeric",
        "in": "media:textable;scalar",
        "out": "media:numeric;scalar"
      }
    },
    "command": "coerce",
    "title": "Coerce Textable Scalar to Numeric",
    "cap_description": "Parse a textable scalar to its numeric representation",
    "metadata": {},
    "args": [
      {
        "media_urn": "media:textable;scalar",
        "required": true,
        "sources": [
          {
            "stdin": "media:textable;scalar"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "The textable scalar value to parse as numeric"
      }
    ],
    "output": {
      "media_urn": "media:numeric;scalar",
      "output_description": "Numeric value parsed from the textable input"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "analyze_image",
        "type": "vision",
        "format": "gguf",
        "model_type": "gguf",
        "in": "media:png;binary",
        "out": "media:vision-inference-output;textable;keyed"
      }
    },
    "command": "analyze_image",
    "title": "Analyze Image with Vision Model (GGUF)",
    "cap_description": "Analyze images using GGUF multimodal models (LLaVA, BakLLaVA) with llama.cpp backend",
    "metadata": {},
    "media_specs": {
      "media:vision-inference-output;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/vision_inference-output",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "required": [
            "success",
            "description",
            "model_name",
            "image_path"
          ],
          "properties": {
            "success": {
              "type": "boolean",
              "description": "Whether the image analysis succeeded"
            },
            "description": {
              "type": "string",
              "description": "Generated description/analysis of the image"
            },
            "model_name": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the vision model used"
            },
            "image_path": {
              "type": "string",
              "description": "Path to the analyzed image"
            },
            "generation_time_ms": {
              "type": "integer",
              "minimum": 0,
              "description": "Analysis time in milliseconds"
            },
            "tokens_generated": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of tokens generated"
            },
            "finish_reason": {
              "type": "string",
              "enum": [
                "stop",
                "length",
                "interrupted"
              ],
              "description": "Why generation finished"
            }
          }
        }
      }
    },
    "args": [
      {
        "media_urn": "media:image-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "cli_flag": "--image"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to the image file to analyze",
        "validation": {
          "pattern": "^[^\\0]+$",
          "min_length": 1
        }
      },
      {
        "media_urn": "media:prompt-text;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--prompt"
          }
        ],
        "arg_description": "Text prompt for the image analysis",
        "validation": {
          "min_length": 1,
          "max_length": 4096
        },
        "default_value": "Describe this image in detail."
      },
      {
        "media_urn": "media:model-spec;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--model-spec"
          }
        ],
        "arg_description": "GGUF vision model specification",
        "validation": {
          "min_length": 1,
          "max_length": 512
        }
      },
      {
        "media_urn": "media:max-tokens;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--max-tokens"
          }
        ],
        "arg_description": "Maximum number of tokens to generate",
        "validation": {
          "min": 1,
          "max": 4096
        },
        "default_value": 512
      },
      {
        "media_urn": "media:temperature;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--temperature"
          }
        ],
        "arg_description": "Sampling temperature (0.0-2.0)",
        "validation": {
          "min": 0,
          "max": 2
        },
        "default_value": 0.7
      },
      {
        "media_urn": "media:top-k;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--top-k"
          }
        ],
        "arg_description": "Top-k sampling parameter",
        "validation": {
          "min": 1,
          "max": 1000
        },
        "default_value": 40
      },
      {
        "media_urn": "media:top-p;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--top-p"
          }
        ],
        "arg_description": "Top-p (nucleus) sampling parameter",
        "validation": {
          "min": 0,
          "max": 1
        },
        "default_value": 0.9
      },
      {
        "media_urn": "media:seed;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--seed"
          }
        ],
        "arg_description": "Random seed for reproducibility",
        "validation": {
          "min": 0,
          "max": 4294967295
        },
        "default_value": 42
      },
      {
        "media_urn": "media:stream-flag;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--stream"
          }
        ],
        "arg_description": "Enable streaming output",
        "default_value": false
      },
      {
        "media_urn": "media:output-path;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--output"
          }
        ],
        "arg_description": "Output JSON file path",
        "validation": {
          "pattern": "^[^\\0]+$"
        }
      }
    ],
    "output": {
      "media_urn": "media:vision-inference-output;textable;keyed",
      "output_description": "Image analysis with description and metadata"
    }
  },
  {
    "urn": {
      "tags": {
        "op": "analyze_image",
        "type": "vision",
        "model_type": "mlx",
        "in": "media:png;binary",
        "out": "media:vision-inference-output;textable;keyed"
      }
    },
    "command": "analyze_image",
    "title": "Analyze Image with Vision Model (MLX)",
    "cap_description": "Analyze images using MLX-based vision-language models on Apple Silicon",
    "metadata": {},
    "media_specs": {
      "media:vision-inference-output;textable;keyed": {
        "media_type": "application/json",
        "profile_uri": "https://capns.org/schema/vision_inference-output",
        "schema": {
          "type": "object",
          "additionalProperties": false,
          "required": [
            "success",
            "description",
            "model_name",
            "image_path"
          ],
          "properties": {
            "success": {
              "type": "boolean",
              "description": "Whether the image analysis succeeded"
            },
            "description": {
              "type": "string",
              "description": "Generated description/analysis of the image"
            },
            "model_name": {
              "type": "string",
              "minLength": 1,
              "description": "Name of the vision model used"
            },
            "image_path": {
              "type": "string",
              "description": "Path to the analyzed image"
            },
            "generation_time_ms": {
              "type": "number",
              "minimum": 0,
              "description": "Analysis time in milliseconds"
            },
            "tokens_generated": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of tokens generated"
            }
          }
        }
      }
    },
    "args": [
      {
        "media_urn": "media:mlx-model-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "cli_flag": "--model"
          },
          {
            "position": 0
          }
        ],
        "arg_description": "Path to MLX vision model directory",
        "validation": {
          "min_length": 1
        }
      },
      {
        "media_urn": "media:image-path;textable;scalar",
        "required": true,
        "sources": [
          {
            "cli_flag": "--image"
          },
          {
            "position": 1
          }
        ],
        "arg_description": "Path to the image file to analyze (local path or HTTP(S) URL)",
        "validation": {
          "min_length": 1
        }
      },
      {
        "media_urn": "media:prompt-text;textable;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--prompt"
          }
        ],
        "arg_description": "Text prompt for the image analysis",
        "validation": {
          "min_length": 1,
          "max_length": 4096
        },
        "default_value": "Describe this image in detail."
      },
      {
        "media_urn": "media:max-tokens;textable;numeric;scalar",
        "required": false,
        "sources": [
          {
            "cli_flag": "--max-tokens"
          }
        ],
        "arg_description": "Maximum number of tokens to generate",
        "validation": {
          "min": 1,
          "max": 4096
        },
        "default_value": 256
      }
    ],
    "output": {
      "media_urn": "media:vision-inference-output;textable;keyed",
      "output_description": "Image analysis with description and metadata"
    }
  }
]